<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VALORANT AIM LAB PRO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@300;400;500;600;700&display=swap');

        :root {
            --val-red: #ff4655;
            --val-dark: #0f1923;
            --val-white: #ece8e1;
            --val-cyan: #00b894;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--val-dark);
            font-family: 'Teko', sans-serif;
            color: var(--val-white);
            user-select: none;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .interactive {
            pointer-events: auto;
            background: rgba(15, 25, 35, 0.85);
            backdrop-filter: blur(8px);
        }

        /* Typography */
        h1 {
            font-size: 80px;
            margin: 0;
            line-height: 0.9;
            color: var(--val-red);
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        h2 { font-size: 32px; margin: 10px 0 30px; font-weight: 300; letter-spacing: 2px; color: #bdc3c7; }

        /* Menu Box */
        .panel {
            background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0) 100%);
            border: 1px solid rgba(255,255,255,0.1);
            border-left: 4px solid var(--val-red);
            padding: 40px 60px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            position: relative;
        }
        
        .panel::before {
            content: '';
            position: absolute;
            top: -5px; right: -5px;
            width: 20px; height: 20px;
            border-top: 2px solid var(--val-red);
            border-right: 2px solid var(--val-red);
        }

        /* Buttons */
        .btn {
            display: block;
            width: 260px;
            padding: 12px 0;
            margin: 10px auto;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--val-white);
            font-family: 'Teko', sans-serif;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--val-red);
            border-color: var(--val-red);
            color: #000;
            font-weight: 700;
            transform: translateX(5px);
        }

        .btn-small { width: 45%; display: inline-block; margin: 5px; font-size: 20px; }

        /* Settings Slider */
        .setting-row {
            margin: 20px 0;
            text-align: left;
        }
        .slider-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 22px;
        }
        input[type=range] {
            width: 150px;
            accent-color: var(--val-red);
        }

        /* HUD */
        #hud {
            justify-content: space-between;
            align-items: flex-start;
            padding: 30px;
            box-sizing: border-box;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.5s;
        }

        .stat-box {
            background: rgba(0,0,0,0.4);
            padding: 10px 20px;
            border-bottom: 2px solid var(--val-red);
            transform: skew(-10deg);
        }
        
        .stat-val { font-size: 42px; font-weight: 600; line-height: 1; }
        .stat-label { font-size: 16px; color: #888; text-transform: uppercase; letter-spacing: 1px; transform: skew(10deg); display: block; }
        .stat-val-inner { transform: skew(10deg); display: block; }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .ch-dot { width: 4px; height: 4px; background: cyan; border-radius: 50%; box-shadow: 0 0 4px cyan; }
        .ch-line { position: absolute; background: rgba(0, 255, 255, 0.5); }
        .ch-h { width: 20px; height: 2px; top: 1px; left: -8px; }
        .ch-v { width: 2px; height: 20px; top: -8px; left: 1px; }

        /* Ammo */
        #ammo-container {
            position: absolute;
            bottom: 30px;
            right: 40px;
            text-align: right;
            pointer-events: none;
        }
        #ammo-val { font-size: 60px; font-weight: 700; line-height: 0.8; }
        #ammo-max { font-size: 24px; color: #888; }

        /* Kill Feed */
        #kill-feed {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
        }
        .kill-msg {
            font-size: 24px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            margin-top: 5px;
            animation: popUp 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popUp { from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } }
        .hs { color: var(--val-red); font-size: 32px; font-weight: 700; }
        .bs { color: var(--val-white); }

        /* Utility Classes */
        .hidden { display: none !important; }
        .visible { opacity: 1 !important; }
        
        /* Pause Hint */
        #pause-hint {
            position: absolute;
            top: 10px; right: 10px;
            font-size: 16px;
            color: rgba(255,255,255,0.3);
        }

        #mode-badge {
            position: absolute;
            bottom: 80px;
            right: 40px;
            font-size: 18px;
            background: #333;
            padding: 2px 8px;
            border-radius: 4px;
            color: #ccc;
        }

    </style>
</head>
<body>

    <!-- Crosshair -->
    <div id="crosshair">
        <div class="ch-line ch-h"></div>
        <div class="ch-line ch-v"></div>
        <div class="ch-dot"></div>
    </div>

    <!-- UI: HUD -->
    <div id="hud" class="ui-layer">
        <div class="stat-box">
            <span class="stat-label">Score</span>
            <span class="stat-val"><span class="stat-val-inner" id="ui-score">0</span></span>
        </div>
        
        <div class="stat-box">
            <span class="stat-label">Time</span>
            <span class="stat-val"><span class="stat-val-inner" id="ui-timer">60</span></span>
        </div>
    </div>

    <div id="ammo-container">
        <div id="ammo-val">25</div>
        <div id="ammo-max">/ ∞</div>
    </div>

    <div id="mode-badge">AUTO</div>
    <div id="kill-feed"></div>
    <div id="pause-hint">按 ESC 暂停</div>

    <!-- UI: Main Menu -->
    <div id="menu-main" class="ui-layer interactive">
        <div class="panel">
            <h1>AIM LAB <span style="font-size:40px; vertical-align:top;">PRO</span></h1>
            <h2>TACTICAL SHOOTER TRAINER</h2>
            
            <button class="btn" onclick="Game.start('easy')">简单 (静态靶)</button>
            <button class="btn" onclick="Game.start('medium')">中等 (移动靶)</button>
            <button class="btn" onclick="Game.start('hard')">困难 (疾速靶)</button>
            
            <div class="setting-row">
                <div class="slider-container">
                    <span style="font-size: 18px; color: #aaa;">SENSITIVITY (灵敏度)</span>
                    <span id="sens-val" style="color: var(--val-red);">0.5</span>
                </div>
                <input type="range" min="0.1" max="2.0" step="0.1" value="0.5" oninput="Game.setSens(this.value)">
            </div>
        </div>
    </div>

    <!-- UI: Pause Menu -->
    <div id="menu-pause" class="ui-layer interactive hidden">
        <div class="panel">
            <h1 style="font-size: 60px;">PAUSED</h1>
            <div style="margin-bottom: 20px; color: #888;">游戏已暂停</div>
            
            <button class="btn" onclick="Game.resume()">继续游戏</button>
            <button class="btn" onclick="Game.restart()">重新开始</button>
            <button class="btn" onclick="Game.toMenu()">退出至主菜单</button>

            <div class="setting-row">
                <div class="slider-container">
                    <span style="font-size: 18px; color: #aaa;">SENSITIVITY</span>
                    <span id="sens-val-pause" style="color: var(--val-red);">0.5</span>
                </div>
                <input type="range" min="0.1" max="2.0" step="0.1" value="0.5" id="pause-sens-slider" oninput="Game.setSens(this.value)">
            </div>
        </div>
    </div>

    <!-- UI: Results -->
    <div id="menu-results" class="ui-layer interactive hidden">
        <div class="panel">
            <h1>SESSION COMPLETE</h1>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 30px 0; text-align: left;">
                <div>FINAL SCORE</div><div id="res-score" style="color: var(--val-red); font-weight: bold; text-align: right;">0</div>
                <div>ACCURACY</div><div id="res-acc" style="text-align: right;">0%</div>
                <div>HEADSHOT %</div><div id="res-hs" style="text-align: right;">0%</div>
                <div>KILLS</div><div id="res-kills" style="text-align: right;">0</div>
            </div>

            <button class="btn" onclick="Game.restart()">再试一次</button>
            <button class="btn" onclick="Game.toMenu()">主菜单</button>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/**
 * VALORANT AIM TRAINER PRO
 * Designed with a focus on professional game loop architecture,
 * separate physics/render loops, and proper input handling.
 */

// --- 1. CONFIGURATION & STATE ---
const Config = {
    colors: {
        sky: 0x0f1923,
        wall: 0x2c3e50,
        floor: 0x1a252f,
        accent: 0xff4655,
        light: 0xffffff
    },
    physics: {
        gravity: 20,
        speed: 12,
        friction: 10
    },
    weapon: {
        fireRate: 0.09, // ~660 RPM (Vandal/Phantom average)
        damage: { head: 150, body: 40, limb: 20 },
        recoilRise: 0.03, // Upward kick per shot
        recoilRecover: 4.0, // Recovery speed
        maxRecoil: 0.3,
        spread: 0.002
    }
};

const State = {
    screen: 'menu', // menu, playing, paused, results
    difficulty: 'easy',
    score: 0,
    time: 60,
    kills: 0,
    shots: 0,
    hits: 0,
    headshots: 0,
    sensitivity: 0.5,
    isFiring: false,
    nextFireTime: 0,
    ammo: 25,
    recoilPitch: 0, // Current recoil value
    isPlaying: false
};

// --- 2. ENGINE & SCENE SETUP ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(Config.colors.sky);
scene.fog = new THREE.FogExp2(Config.colors.sky, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

// --- 3. CUSTOM INPUT & CAMERA CONTROLLER ---
// To fix the "slanted" perspective, we implement a proper Pitch/Yaw system manually
// instead of using generic PointerLockControls which can accumulate Roll error.
const Input = {
    keys: { w:false, a:false, s:false, d:false },
    locked: false,
    
    init: function() {
        document.addEventListener('keydown', (e) => this.onKey(e, true));
        document.addEventListener('keyup', (e) => this.onKey(e, false));
        document.addEventListener('mousedown', (e) => {
            if(State.screen === 'playing' && this.locked) {
                if(e.button === 0) State.isFiring = true;
            } else if (State.screen === 'menu' || State.screen === 'paused') {
                // UI clicks handled by buttons
            }
        });
        document.addEventListener('mouseup', () => State.isFiring = false);
        document.addEventListener('mousemove', (e) => this.onMove(e));
        document.addEventListener('pointerlockchange', () => this.onLockChange());
        
        // Settings sliders init
        document.getElementById('pause-sens-slider').value = State.sensitivity;
    },

    onKey: function(e, down) {
        const key = e.code.toLowerCase();
        if (key === 'keyw') this.keys.w = down;
        if (key === 'keya') this.keys.a = down;
        if (key === 'keys') this.keys.s = down;
        if (key === 'keyd') this.keys.d = down;
        if (key === 'keyr' && down) Game.reload();
        if (key === 'escape' && down) Game.togglePause();
    },

    onMove: function(e) {
        if (!this.locked || State.screen !== 'playing') return;
        
        // Apply mouse movement
        // Yaw (Y-axis) rotates the Player Body
        Player.yawObject.rotation.y -= e.movementX * 0.002 * State.sensitivity;
        
        // Pitch (X-axis) rotates the Camera Holder
        Player.pitch -= e.movementY * 0.002 * State.sensitivity;
        
        // Clamp pitch to avoid neck breaking (89 degrees)
        Player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, Player.pitch));
    },

    requestLock: function() {
        document.body.requestPointerLock();
    },

    unlock: function() {
        document.exitPointerLock();
    },

    onLockChange: function() {
        this.locked = (document.pointerLockElement === document.body);
        if (!this.locked && State.screen === 'playing') {
            Game.togglePause(true); // Force pause if lost focus
        }
    }
};

const Player = {
    yawObject: new THREE.Group(),   // Handles Horizontal rotation & Position
    pitchObject: new THREE.Group(), // Handles Vertical rotation
    pitch: 0,
    velocity: new THREE.Vector3(),
    height: 1.7,
    
    init: function() {
        scene.add(this.yawObject);
        this.yawObject.add(this.pitchObject);
        this.pitchObject.add(camera); // Camera is child of Pitch
        this.pitchObject.position.y = this.height;
        this.yawObject.position.set(0, 0, 8); // Start position
    },

    update: function(dt) {
        if (State.screen !== 'playing') return;

        // 1. Apply Rotation (including recoil offset)
        // We add recoil to the visual pitch, but not the logical pitch variable
        // so when recoil recovers, it goes back to where the player was looking.
        this.pitchObject.rotation.x = this.pitch + State.recoilPitch;

        // 2. Movement Physics
        const speed = Config.physics.speed;
        const dir = new THREE.Vector3();
        
        // Calculate move direction relative to Yaw
        const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), this.yawObject.rotation.y);
        const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), this.yawObject.rotation.y);

        if (Input.keys.w) dir.add(forward);
        if (Input.keys.s) dir.sub(forward);
        if (Input.keys.d) dir.add(right);
        if (Input.keys.a) dir.sub(right);

        if (dir.lengthSq() > 0) dir.normalize();

        // Simple inertia/acceleration
        this.velocity.x += dir.x * speed * dt * 5; // Acceleration
        this.velocity.z += dir.z * speed * dt * 5;
        
        // Friction
        this.velocity.x -= this.velocity.x * 10 * dt;
        this.velocity.z -= this.velocity.z * 10 * dt;

        this.yawObject.position.x += this.velocity.x * dt;
        this.yawObject.position.z += this.velocity.z * dt;

        // Bounds check (Simple room clamp)
        this.yawObject.position.x = Math.max(-14, Math.min(14, this.yawObject.position.x));
        this.yawObject.position.z = Math.max(0, Math.min(18, this.yawObject.position.z));
    }
};

// --- 4. ENVIRONMENT GENERATION ---
// Create a professional looking training hall using procedural textures
function createTexture(color, noise = true) {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    // Base
    ctx.fillStyle = color;
    ctx.fillRect(0,0,512,512);
    
    // Noise
    if (noise) {
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        for(let i=0; i<10000; i++) {
            ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
        }
        // Grid lines
        ctx.strokeStyle = 'rgba(255,255,255,0.05)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0; i<=512; i+=64) {
            ctx.moveTo(i, 0); ctx.lineTo(i, 512);
            ctx.moveTo(0, i); ctx.lineTo(512, i);
        }
        ctx.stroke();
    }
    
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    return tex;
}

function initEnvironment() {
    const matFloor = new THREE.MeshStandardMaterial({ 
        map: createTexture('#1a252f'), 
        roughness: 0.8, metalness: 0.2 
    });
    const matWall = new THREE.MeshStandardMaterial({ 
        map: createTexture('#2c3e50'), 
        roughness: 0.5, metalness: 0.1 
    });
    const matTrim = new THREE.MeshStandardMaterial({ color: Config.colors.accent, emissive: Config.colors.accent, emissiveIntensity: 0.2 });

    // 1. Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 60), matFloor);
    floor.rotation.x = -Math.PI/2;
    floor.material.map.repeat.set(10, 15);
    floor.receiveShadow = true;
    scene.add(floor);

    // 2. Ceiling
    const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(40, 60), matWall);
    ceiling.rotation.x = Math.PI/2;
    ceiling.position.y = 8;
    scene.add(ceiling);

    // 3. Walls
    const createWall = (w, h, d, x, y, z) => {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), matWall);
        mesh.position.set(x, y, z);
        mesh.receiveShadow = true;
        scene.add(mesh);
        return mesh;
    };

    // Back wall (Target area)
    createWall(40, 10, 2, 0, 5, -25);
    // Side walls
    createWall(2, 10, 60, -20, 5, 0);
    createWall(2, 10, 60, 20, 5, 0);
    // Back Player Wall
    createWall(40, 10, 2, 0, 5, 25);

    // 4. Pillars & Details
    const pillarGeo = new THREE.BoxGeometry(1, 8, 1);
    for(let x=-15; x<=15; x+=10) {
        for(let z=-10; z<=10; z+=10) {
            const p = new THREE.Mesh(pillarGeo, matWall);
            p.position.set(x, 4, z);
            p.castShadow = true;
            p.receiveShadow = true;
            scene.add(p);
            
            // Neon Trim
            const trim = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.1, 1.1), matTrim);
            trim.position.set(x, 1, z);
            scene.add(trim);
        }
    }

    // 5. Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);

    // Main Spotlights for Arena feel
    const createSpot = (x, z) => {
        const spot = new THREE.SpotLight(0xffffff, 1);
        spot.position.set(x, 7.5, z);
        spot.angle = Math.PI / 4;
        spot.penumbra = 0.5;
        spot.decay = 2;
        spot.distance = 30;
        spot.castShadow = true;
        spot.shadow.mapSize.width = 1024;
        spot.shadow.mapSize.height = 1024;
        scene.add(spot);
        
        // Visual fixture
        const fix = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.5), matTrim);
        fix.position.set(x, 7.9, z);
        scene.add(fix);
    };

    createSpot(0, 0);
    createSpot(-10, -10);
    createSpot(10, -10);
    createSpot(0, -15);
}

// --- 5. WEAPON & SHOOTING SYSTEM ---
const Weapon = {
    mesh: new THREE.Group(),
    muzzle: new THREE.Vector3(0, 0, -0.6),
    
    init: function() {
        // Construct a "Phantom" style gun
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3 });
        const accentMat = new THREE.MeshStandardMaterial({ color: 0xececec, roughness: 0.1 });
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

        const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 0.5), bodyMat);
        const topRail = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.05, 0.5), accentMat);
        topRail.position.y = 0.1;
        
        const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4, 8), barrelMat);
        barrel.rotation.x = Math.PI/2;
        barrel.position.set(0, 0.05, -0.4);
        
        const mag = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.1), new THREE.MeshStandardMaterial({color:0x333333}));
        mag.position.set(0, -0.15, 0);
        mag.rotation.x = 0.2;

        const sight = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.1), new THREE.MeshStandardMaterial({color:Config.colors.accent}));
        sight.position.set(0, 0.14, 0.2);

        this.mesh.add(body, topRail, barrel, mag, sight);
        this.mesh.position.set(0.25, -0.25, -0.4);
        Player.pitchObject.add(this.mesh); // Attach to camera holder
    },

    update: function(dt, time) {
        if (!State.isPlaying) return;

        // 1. Handling Firing
        if (State.isFiring && State.ammo > 0 && time > State.nextFireTime) {
            this.fire(time);
        }

        // 2. Weapon Sway (Movement)
        const v = Player.velocity;
        const swayX = Math.sin(time * 10) * v.length() * 0.002;
        const swayY = Math.cos(time * 20) * v.length() * 0.002;
        this.mesh.position.x = 0.25 + swayX;
        this.mesh.position.y = -0.25 + swayY;

        // 3. Recoil Kick Animation (Visual Gun Kick)
        // Lerp back to origin
        this.mesh.position.z += ( -0.4 - this.mesh.position.z ) * 10 * dt;
        this.mesh.rotation.x += ( 0 - this.mesh.rotation.x ) * 10 * dt;

        // 4. Camera Recoil Recovery (The actual aim)
        if (!State.isFiring && State.recoilPitch > 0) {
            State.recoilPitch -= Config.weapon.recoilRecover * dt * State.recoilPitch;
            if (State.recoilPitch < 0.001) State.recoilPitch = 0;
        }
    },

    fire: function(time) {
        State.nextFireTime = time + Config.weapon.fireRate;
        State.ammo--;
        State.shots++;
        AudioSys.play('shoot');
        
        // 1. Apply Recoil
        // Kick gun model back
        this.mesh.position.z += 0.15;
        this.mesh.rotation.x += 0.1;
        
        // Kick Camera Up (Recoil)
        if (State.recoilPitch < Config.weapon.maxRecoil) {
            State.recoilPitch += Config.weapon.recoilRise;
        }

        // 2. Raycast
        const spreadX = (Math.random() - 0.5) * Config.weapon.spread * (1 + State.recoilPitch * 10);
        const spreadY = (Math.random() - 0.5) * Config.weapon.spread * (1 + State.recoilPitch * 10);
        
        // We raycast from camera position, but direction includes recoil + spread
        const raycaster = new THREE.Raycaster();
        // Create a vector representing where we are looking (0,0) plus spread
        const dir = new THREE.Vector3(spreadX, spreadY, -1);
        dir.applyQuaternion(Player.pitchObject.getWorldQuaternion(new THREE.Quaternion()));
        dir.normalize();

        raycaster.set(Player.pitchObject.getWorldPosition(new THREE.Vector3()), dir);

        // Get intersections
        const hits = raycaster.intersectObjects(Bots.group.children, true);
        
        // Muzzle Flash
        this.createFlash();

        if (hits.length > 0) {
            const hit = hits[0];
            const obj = hit.object;
            
            // Visual Impact
            this.createImpact(hit.point, hit.face.normal);

            if (obj.userData && obj.userData.bot) {
                obj.userData.bot.hit(obj.userData.part);
            }
        }

        Game.updateHUD();
        if(State.ammo === 0) Game.reload();
    },

    createFlash: function() {
        const light = new THREE.PointLight(0xffffaa, 5, 2);
        light.position.set(0, 0.1, -0.6);
        this.mesh.add(light);
        setTimeout(() => this.mesh.remove(light), 50);
    },

    createImpact: function(pos, norm) {
        // Simple spark
        const geo = new THREE.PlaneGeometry(0.1, 0.1);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos).add(norm.multiplyScalar(0.01));
        mesh.lookAt(pos.clone().add(norm));
        scene.add(mesh);
        setTimeout(() => scene.remove(mesh), 200);
    }
};

// --- 6. BOT SYSTEM ---
const Bots = {
    group: new THREE.Group(),
    active: [],
    
    init: function() {
        scene.add(this.group);
    },

    spawn: function() {
        const bot = new Bot();
        this.active.push(bot);
        this.group.add(bot.mesh);
    },

    update: function(dt) {
        // Update positions and remove dead ones
        for (let i = this.active.length - 1; i >= 0; i--) {
            const bot = this.active[i];
            bot.update(dt);
            if (bot.dead && bot.canRemove) {
                this.group.remove(bot.mesh);
                this.active.splice(i, 1);
            }
        }
        
        // Spawn manager
        const targetCount = State.difficulty === 'hard' ? 5 : 3;
        if (State.isPlaying && this.active.length < targetCount && Math.random() < 0.05) {
            this.spawn();
        }
    },
    
    clear: function() {
        while(this.active.length > 0) {
            const b = this.active.pop();
            this.group.remove(b.mesh);
        }
    }
};

class Bot {
    constructor() {
        this.health = 100;
        this.dead = false;
        this.canRemove = false;
        this.spawnTime = Date.now();
        this.dir = Math.sign(Math.random() - 0.5);
        this.speed = State.difficulty === 'easy' ? 0 : (State.difficulty === 'medium' ? 2 : 5);

        // Meshes
        this.mesh = new THREE.Group();
        
        const matHead = new THREE.MeshStandardMaterial({ color: Config.colors.accent, roughness: 0.2 });
        const matBody = new THREE.MeshStandardMaterial({ color: Config.colors.accent, roughness: 0.5, transparent: true, opacity: 0.6 });

        // Head
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), matHead);
        head.position.y = 1.7;
        head.userData = { bot: this, part: 'head' };
        this.mesh.add(head);

        // Body
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.25), matBody);
        body.position.y = 1.1;
        body.userData = { bot: this, part: 'body' };
        this.mesh.add(body);

        // Stand
        const stand = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.3, 0.1, 8), new THREE.MeshStandardMaterial({color:0x333333}));
        stand.position.y = 0.05;
        this.mesh.add(stand);
        
        // Random pos
        const x = (Math.random() - 0.5) * 25;
        const z = -15 - Math.random() * 8;
        this.mesh.position.set(x, 0, z);
        this.mesh.scale.set(0,0,0); // For spawn anim
        
        // Floating motion base
        this.baseY = 0;
    }

    update(dt) {
        if (this.dead) {
            this.mesh.scale.multiplyScalar(0.9);
            if (this.mesh.scale.x < 0.1) this.canRemove = true;
            return;
        }

        // Spawn In
        if (this.mesh.scale.x < 1) this.mesh.scale.addScalar(dt * 4);

        // Movement
        this.mesh.position.x += this.dir * this.speed * dt;
        if (this.mesh.position.x > 14 || this.mesh.position.x < -14) this.dir *= -1;
        
        // Hard mode strafing
        if (State.difficulty === 'hard' && Math.random() < 0.02) this.dir *= -1;

        // Despawn check
        const life = (Date.now() - this.spawnTime) / 1000;
        const maxLife = State.difficulty === 'hard' ? 4 : (State.difficulty === 'medium' ? 6 : 999);
        if (life > maxLife) this.die(false);
    }

    hit(part) {
        if(this.dead) return;
        
        let dmg = 0;
        if (part === 'head') {
            dmg = Config.weapon.damage.head;
            State.headshots++;
            AudioSys.play('hs');
            Game.showKillMsg("HEADSHOT", true);
        } else {
            dmg = Config.weapon.damage.body;
            State.hits++;
            AudioSys.play('body');
            Game.showKillMsg(dmg, false);
        }
        
        this.health -= dmg;
        State.score += dmg;
        
        // Flash
        this.mesh.children.forEach(c => {
            if(c.material && c.material.emissive) {
                const old = c.material.emissive.getHex();
                c.material.emissive.setHex(0xffffff);
                setTimeout(()=>c.material.emissive.setHex(old), 50);
            }
        });

        if (this.health <= 0) this.die(true);
        Game.updateHUD();
    }

    die(killed) {
        this.dead = true;
        if(killed) {
            State.kills++;
            AudioSys.play('kill');
        }
    }
}

// --- 7. AUDIO SYSTEM ---
const AudioSys = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    play: function(type) {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        const now = this.ctx.currentTime;

        if (type === 'shoot') {
            // Vandal-like sharp sound
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'hs') {
            // Satisfying DING
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        } else if (type === 'kill') {
            // Bass thump
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'body') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.05);
            osc.start(now);
            osc.stop(now + 0.05);
        }
    }
};

// --- 8. GAME LOOP & MANAGEMENT ---
const Game = {
    init: function() {
        initEnvironment();
        Player.init();
        Weapon.init();
        Input.init();
        Bots.init();
        
        // Loop
        let lastTime = performance.now();
        const animate = () => {
            requestAnimationFrame(animate);
            const time = performance.now();
            const dt = Math.min((time - lastTime) / 1000, 0.1); // Cap dt
            lastTime = time;
            
            this.update(dt, time / 1000);
            renderer.render(scene, camera);
        };
        animate();
    },

    start: function(diff) {
        State.difficulty = diff;
        State.score = 0;
        State.time = 60;
        State.kills = 0;
        State.shots = 0;
        State.headshots = 0;
        State.ammo = 25;
        State.isPlaying = true;
        State.screen = 'playing';
        State.recoilPitch = 0;
        
        Bots.clear();
        Bots.spawn();

        this.updateHUD();
        
        // Hide Menus
        document.querySelectorAll('.ui-layer.interactive').forEach(el => el.classList.add('hidden'));
        document.getElementById('hud').classList.add('visible');
        
        Input.requestLock();
    },

    update: function(dt, time) {
        if (State.screen !== 'playing') return;

        State.time -= dt;
        if (State.time <= 0) {
            this.end();
            return;
        }

        Player.update(dt);
        Weapon.update(dt, time);
        Bots.update(dt);
        
        // HUD Timer
        document.getElementById('ui-timer').innerText = Math.ceil(State.time);
    },

    updateHUD: function() {
        document.getElementById('ui-score').innerText = State.score;
        document.getElementById('ammo-val').innerText = State.ammo;
        if(State.ammo < 5) document.getElementById('ammo-val').style.color = 'red';
        else document.getElementById('ammo-val').style.color = 'white';
    },

    togglePause: function(forcePause) {
        if (State.screen === 'menu' || State.screen === 'results') return;
        
        if (State.screen === 'playing' || forcePause) {
            State.screen = 'paused';
            State.isPlaying = false;
            State.isFiring = false;
            Input.unlock();
            document.getElementById('menu-pause').classList.remove('hidden');
        } else if (State.screen === 'paused' && !forcePause) {
            this.resume();
        }
    },

    resume: function() {
        State.screen = 'playing';
        State.isPlaying = true;
        document.getElementById('menu-pause').classList.add('hidden');
        Input.requestLock();
    },

    restart: function() {
        this.start(State.difficulty);
    },

    toMenu: function() {
        State.screen = 'menu';
        State.isPlaying = false;
        Bots.clear();
        document.getElementById('menu-pause').classList.add('hidden');
        document.getElementById('menu-results').classList.add('hidden');
        document.getElementById('menu-main').classList.remove('hidden');
        document.getElementById('hud').classList.remove('visible');
        Input.unlock();
        
        // Reset cam for menu
        Player.yawObject.position.set(0,0,8);
        Player.yawObject.rotation.y = 0;
        Player.pitch = 0;
    },

    end: function() {
        State.screen = 'results';
        State.isPlaying = false;
        State.isFiring = false;
        Input.unlock();

        document.getElementById('hud').classList.remove('visible');
        document.getElementById('menu-results').classList.remove('hidden');

        const acc = State.shots > 0 ? Math.round((State.hits + State.headshots) / State.shots * 100) : 0;
        const hs = State.kills > 0 ? Math.round(State.headshots / State.kills * 100) : 0;

        document.getElementById('res-score').innerText = State.score;
        document.getElementById('res-acc').innerText = acc + "%";
        document.getElementById('res-hs').innerText = hs + "%";
        document.getElementById('res-kills').innerText = State.kills;
    },

    reload: function() {
        if(State.ammo === 25) return;
        State.isFiring = false;
        // Simple reload anim
        Weapon.mesh.rotation.x = -1;
        document.getElementById('ammo-val').innerText = "RLD";
        setTimeout(() => {
            Weapon.mesh.rotation.x = 0;
            State.ammo = 25;
            this.updateHUD();
        }, 1000);
    },

    setSens: function(val) {
        State.sensitivity = parseFloat(val);
        document.getElementById('sens-val').innerText = val;
        document.getElementById('sens-val-pause').innerText = val;
        document.getElementById('pause-sens-slider').value = val;
    },

    showKillMsg: function(txt, isHS) {
        const d = document.createElement('div');
        d.className = 'kill-msg ' + (isHS ? 'hs' : 'bs');
        d.innerText = isHS ? "HEADSHOT" : txt;
        document.getElementById('kill-feed').appendChild(d);
        setTimeout(() => d.remove(), 1000);
    }
};

// Start
Game.init();

// Handle window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
