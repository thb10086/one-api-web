<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>打瓦小子练枪 (Valorant Aim Trainer)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@400;600&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f1923; /* Valorant Dark Blue */
            font-family: 'Teko', sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        /* UI Layers */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas when playing */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .interactive {
            pointer-events: auto;
            background: rgba(15, 25, 35, 0.95);
            backdrop-filter: blur(5px);
        }

        /* Main Menu */
        h1 {
            font-size: 80px;
            margin: 0;
            color: #ff4655; /* Valorant Red */
            text-transform: uppercase;
            letter-spacing: 5px;
            text-shadow: 2px 2px 0px #000;
        }

        .menu-box {
            text-align: center;
            border: 2px solid #53636e;
            padding: 40px;
            background: rgba(0, 0, 0, 0.5);
        }

        .btn {
            background: transparent;
            border: 1px solid white;
            color: white;
            padding: 10px 40px;
            font-size: 24px;
            font-family: 'Teko', sans-serif;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
            text-transform: uppercase;
            width: 200px;
        }

        .btn:hover {
            background: #ff4655;
            border-color: #ff4655;
            color: black;
            font-weight: bold;
        }

        /* HUD */
        #hud {
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-stat {
            text-align: center;
        }

        .hud-label {
            font-size: 20px;
            color: #bdc3c7;
            letter-spacing: 1px;
        }

        .hud-value {
            font-size: 48px;
            font-weight: 600;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background-color: #00ff00; /* Classic Green */
            border-radius: 50%;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
            pointer-events: none;
        }
        
        /* Crosshair outer lines */
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(0, 255, 0, 0.5);
        }
        #crosshair::before { top: -6px; left: 1px; width: 2px; height: 16px; }
        #crosshair::after { top: 1px; left: -6px; width: 16px; height: 2px; }

        /* Kill Feed / Hit Marker */
        #kill-feed {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }
        
        .kill-msg {
            font-size: 24px;
            opacity: 1;
            transition: opacity 1s;
            text-shadow: 1px 1px 2px black;
        }
        .headshot { color: #ff4655; font-size: 32px; font-weight: bold; }
        .bodyshot { color: white; }

        /* Results Screen */
        #results { display: none; }
        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            text-align: left;
        }

        .hidden { display: none !important; }

        #ammo-display {
            position: absolute;
            bottom: 20px;
            right: 40px;
            font-size: 40px;
            text-align: right;
        }
        .ammo-bar {
            width: 10px;
            height: 30px;
            background: white;
            display: inline-block;
            margin-left: 2px;
            transform: skew(-20deg);
        }

    </style>
</head>
<body>

<div id="game-container">
    <!-- Crosshair -->
    <div id="crosshair"></div>

    <!-- HUD -->
    <div id="hud" class="ui-layer">
        <div class="hud-stat">
            <div class="hud-value" id="score">0</div>
            <div class="hud-label">得分 (SCORE)</div>
        </div>
        <div class="hud-stat">
            <div class="hud-value" id="timer">60</div>
            <div class="hud-label">时间 (TIME)</div>
        </div>
    </div>

    <!-- Ammo -->
    <div id="ammo-display" class="ui-layer" style="pointer-events: none; justify-content: flex-end; align-items: flex-end;">
        <div id="ammo-count">25 / ∞</div>
    </div>

    <!-- Kill Feed -->
    <div id="kill-feed" class="ui-layer" style="pointer-events: none; height: auto; top: auto; bottom: 15%;"></div>

    <!-- Main Menu -->
    <div id="menu" class="ui-layer interactive">
        <div class="menu-box">
            <h1>AIM TRAINER 3D</h1>
            <p style="color: #bdc3c7; letter-spacing: 2px; margin-bottom: 40px;">瓦洛兰特模拟练枪</p>
            
            <div style="margin-bottom: 20px;">
                <p>选择难度 (DIFFICULTY)</p>
                <button class="btn" onclick="startGame('easy')">简单 (静态)</button><br>
                <button class="btn" onclick="startGame('medium')">中等 (移动)</button><br>
                <button class="btn" onclick="startGame('hard')">困难 (疾速)</button>
            </div>
            <div style="font-size: 14px; color: #7f8c8d; margin-top: 20px;">
                WASD 移动 | 鼠标瞄准 | 左键射击 | R 换弹 | ESC 暂停
            </div>
        </div>
    </div>

    <!-- Results Screen -->
    <div id="results" class="ui-layer interactive hidden">
        <div class="menu-box">
            <h1>训练结束</h1>
            <div class="stat-grid">
                <div>最终得分:</div><div id="res-score" style="color:#ff4655">0</div>
                <div>命中率:</div><div id="res-accuracy">0%</div>
                <div>爆头率:</div><div id="res-headshot">0%</div>
                <div>击杀数:</div><div id="res-kills">0</div>
            </div>
            <button class="btn" onclick="location.reload()">再来一局</button>
        </div>
    </div>
</div>

<!-- Three.js Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

<script>
    // --- Configuration ---
    const CONFIG = {
        colors: {
            bg: 0x0f1923,
            grid: 0x2c3e50,
            botBody: 0x00b894, // Cyan/Teal like The Range
            botHead: 0xff4655, // Hitbox color (can be hidden or visible)
            botLimb: 0x0984e3,
            wall: 0x1f2933,
            floor: 0x16202a
        },
        player: {
            speed: 15,
            height: 1.8
        },
        weapon: {
            damage: { head: 100, body: 40, limb: 20 },
            fireRate: 0.1, // seconds
            recoil: 0.05,
            ammo: 25
        }
    };

    let GAME = {
        state: 'menu', // menu, playing, over
        difficulty: 'easy',
        score: 0,
        shotsFired: 0,
        shotsHit: 0,
        headshots: 0,
        kills: 0,
        timeLeft: 60,
        lastTime: 0,
        ammo: CONFIG.weapon.ammo,
        lastShotTime: 0,
        targets: []
    };

    // --- Audio System (Synthesized) ---
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioCtx();

    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        const now = audioCtx.currentTime;

        if (type === 'shoot') {
            // Gunshot: Noise burst + rapid pitch drop
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'hit_body') {
            // Thud
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(150, now);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'hit_head') {
            // High pitched ding (Valorant style)
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
        } else if (type === 'kill') {
            // Kill confirmation bass
            osc.type = 'square';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        }
    }

    // --- Three.js Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(CONFIG.colors.bg);
    // Add some fog for depth
    scene.fog = new THREE.Fog(CONFIG.colors.bg, 10, 50);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('game-container').appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    scene.add(dirLight);

    // Controls
    const controls = new THREE.PointerLockControls(camera, document.body);
    const moveState = { forward: false, backward: false, left: false, right: false };

    // --- Environment ---
    function createEnvironment() {
        // Floor
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        // Grid Texture
        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#16202a';
        ctx.fillRect(0,0,128,128);
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 2;
        ctx.strokeRect(0,0,128,128);
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(50, 50);

        const floorMat = new THREE.MeshStandardMaterial({ map: texture });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Walls (Shooting range style)
        const wallMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.wall });
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(100, 20, 1), wallMat);
        backWall.position.set(0, 10, -25);
        backWall.receiveShadow = true;
        scene.add(backWall);

        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(1, 20, 50), wallMat);
        leftWall.position.set(-25, 10, 0);
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(1, 20, 50), wallMat);
        rightWall.position.set(25, 10, 0);
        rightWall.receiveShadow = true;
        scene.add(rightWall);
    }
    createEnvironment();

    // Weapon Model (Simple visual attached to camera)
    const weaponGroup = new THREE.Group();
    function createWeapon() {
        const mat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.6), mat);
        const barrel = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.4), new THREE.MeshStandardMaterial({color: 0x111111}));
        barrel.position.set(0, 0.05, -0.4);
        weaponGroup.add(body);
        weaponGroup.add(barrel);
        weaponGroup.position.set(0.2, -0.3, -0.5);
        camera.add(weaponGroup);
        scene.add(camera);
    }
    createWeapon();

    // --- Bot Logic ---
    class Bot {
        constructor() {
            this.mesh = new THREE.Group();
            this.health = 100;
            this.active = true;
            this.spawnTime = Date.now();
            this.moveDirection = Math.random() > 0.5 ? 1 : -1;

            // Materials
            const headMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.botHead, roughness: 0.2 });
            const bodyMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.botBody, roughness: 0.5 });
            const limbMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.botLimb });

            // 1. Head (Hitbox: Head)
            const headGeo = new THREE.SphereGeometry(0.15, 16, 16);
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.7;
            head.userData = { type: 'head', parent: this };
            this.mesh.add(head);

            // 2. Torso (Hitbox: Body)
            const torsoGeo = new THREE.BoxGeometry(0.4, 0.6, 0.25);
            const torso = new THREE.Mesh(torsoGeo, bodyMat);
            torso.position.y = 1.25;
            torso.userData = { type: 'body', parent: this };
            this.mesh.add(torso);

            // 3. Limbs (Arms/Legs)
            // Left Arm
            const armGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.6);
            const lArm = new THREE.Mesh(armGeo, limbMat);
            lArm.position.set(-0.3, 1.3, 0);
            lArm.userData = { type: 'limb', parent: this };
            this.mesh.add(lArm);
            // Right Arm
            const rArm = new THREE.Mesh(armGeo, limbMat);
            rArm.position.set(0.3, 1.3, 0);
            rArm.userData = { type: 'limb', parent: this };
            this.mesh.add(rArm);
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.8);
            const lLeg = new THREE.Mesh(legGeo, limbMat);
            lLeg.position.set(-0.15, 0.4, 0);
            lLeg.userData = { type: 'limb', parent: this };
            this.mesh.add(lLeg);
            const rLeg = new THREE.Mesh(legGeo, limbMat);
            rLeg.position.set(0.15, 0.4, 0);
            rLeg.userData = { type: 'limb', parent: this };
            this.mesh.add(rLeg);

            // Spawn Position (Randomized range)
            const x = (Math.random() - 0.5) * 30; // Width -15 to 15
            const z = -10 - Math.random() * 10;   // Depth -10 to -20
            this.mesh.position.set(x, 0, z);

            // Shadow
            this.mesh.traverse(child => {
                if(child.isMesh) child.castShadow = true;
            });

            scene.add(this.mesh);
            GAME.targets.push(this);
            
            // Pop in effect
            this.mesh.scale.set(0,0,0);
        }

        update(dt) {
            // Spawn animation
            if (this.mesh.scale.x < 1) {
                this.mesh.scale.addScalar(dt * 5);
                if(this.mesh.scale.x > 1) this.mesh.scale.set(1,1,1);
            }

            // Movement (Based on difficulty)
            if (GAME.difficulty !== 'easy') {
                const speed = GAME.difficulty === 'medium' ? 2 : 5;
                this.mesh.position.x += this.moveDirection * speed * dt;
                
                // Change direction at bounds
                if (this.mesh.position.x > 18 || this.mesh.position.x < -18) {
                    this.moveDirection *= -1;
                }
                
                // Random erratic movement for Hard mode
                if (GAME.difficulty === 'hard' && Math.random() < 0.02) {
                    this.moveDirection *= -1;
                }
            }

            // Despawn logic (Hard mode bots disappear faster)
            const lifeTime = (Date.now() - this.spawnTime) / 1000;
            const maxLife = GAME.difficulty === 'hard' ? 3 : (GAME.difficulty === 'medium' ? 5 : 999);
            
            if (lifeTime > maxLife) {
                this.remove();
            }
        }

        hit(part) {
            let dmg = 0;
            let isHeadshot = false;

            if (part === 'head') {
                dmg = CONFIG.weapon.damage.head;
                isHeadshot = true;
                playSound('hit_head');
                showKillMsg("HEADSHOT", true);
                GAME.headshots++;
            } else if (part === 'body') {
                dmg = CONFIG.weapon.damage.body;
                playSound('hit_body');
                showKillMsg("BODY", false);
            } else {
                dmg = CONFIG.weapon.damage.limb;
                playSound('hit_body');
            }

            this.health -= dmg;
            GAME.shotsHit++;
            GAME.score += dmg;
            updateHUD();

            // Hit feedback (flash white)
            this.mesh.traverse(c => {
                if(c.isMesh) {
                    c.material.emissive = new THREE.Color(0xffffff);
                    c.material.emissiveIntensity = 0.5;
                    setTimeout(() => { 
                        c.material.emissiveIntensity = 0; 
                    }, 50);
                }
            });

            if (this.health <= 0) {
                playSound('kill');
                GAME.kills++;
                this.remove();
            }
        }

        remove() {
            this.active = false;
            // Death particle or shrink
            this.mesh.scale.multiplyScalar(0.8);
            scene.remove(this.mesh);
            // Clean up from array handled in main loop
        }
    }

    // --- Game Logic ---

    function initGame() {
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        document.addEventListener('mousedown', onMouseDown);
        window.addEventListener('resize', onWindowResize);
        
        controls.addEventListener('lock', () => {
            // Only resume if we were playing, not game over
            if (GAME.state === 'playing') {
                // good
            }
        });
        
        controls.addEventListener('unlock', () => {
            if (GAME.state === 'playing') {
                // Optional: Pause menu
            }
        });

        renderer.setAnimationLoop(animate);
    }

    function startGame(diff) {
        GAME.difficulty = diff;
        GAME.score = 0;
        GAME.shotsFired = 0;
        GAME.shotsHit = 0;
        GAME.headshots = 0;
        GAME.kills = 0;
        GAME.timeLeft = 60;
        GAME.ammo = CONFIG.weapon.ammo;
        GAME.targets.forEach(t => scene.remove(t.mesh));
        GAME.targets = [];

        document.getElementById('menu').classList.add('hidden');
        document.getElementById('results').classList.add('hidden');
        document.getElementById('hud').style.display = 'flex';
        
        controls.lock();
        GAME.state = 'playing';
        GAME.lastTime = performance.now();
        
        // Reset player position
        camera.position.set(0, CONFIG.player.height, 10);
        camera.rotation.set(0,0,0);

        updateHUD();
        spawnBot();
    }

    function gameOver() {
        GAME.state = 'over';
        controls.unlock();
        
        document.getElementById('hud').style.display = 'none';
        document.getElementById('results').classList.remove('hidden');

        // Stats
        const accuracy = GAME.shotsFired > 0 ? Math.round((GAME.shotsHit / GAME.shotsFired) * 100) : 0;
        const hsRate = GAME.kills > 0 ? Math.round((GAME.headshots / GAME.kills) * 100) : 0;

        document.getElementById('res-score').innerText = GAME.score;
        document.getElementById('res-accuracy').innerText = accuracy + "%";
        document.getElementById('res-headshot').innerText = hsRate + "%";
        document.getElementById('res-kills').innerText = GAME.kills;
    }

    function spawnBot() {
        if (GAME.state !== 'playing') return;
        
        // Ensure we keep a certain number of bots
        const maxBots = GAME.difficulty === 'easy' ? 3 : (GAME.difficulty === 'medium' ? 4 : 6);
        
        if (GAME.targets.length < maxBots) {
            new Bot();
        }

        // Random next spawn
        const delay = GAME.difficulty === 'hard' ? 500 : 1000;
        setTimeout(spawnBot, delay);
    }

    // --- Interaction ---
    const raycaster = new THREE.Raycaster();
    const center = new THREE.Vector2(0, 0);

    function onMouseDown(event) {
        if (GAME.state !== 'playing' || !controls.isLocked) return;
        
        const now = Date.now();
        if (now - GAME.lastShotTime < CONFIG.weapon.fireRate * 1000) return;
        if (GAME.ammo <= 0) {
            reload();
            return;
        }

        GAME.lastShotTime = now;
        GAME.ammo--;
        GAME.shotsFired++;
        playSound('shoot');
        
        // Recoil
        weaponGroup.position.z += 0.2; // kick back
        camera.rotation.x += CONFIG.weapon.recoil * (Math.random() * 0.5 + 0.5);

        // Raycast
        raycaster.setFromCamera(center, camera);
        
        // Get all meshes from all active bots
        let candidateMeshes = [];
        GAME.targets.forEach(bot => {
            bot.mesh.traverse(child => {
                if(child.isMesh) candidateMeshes.push(child);
            });
        });

        const intersects = raycaster.intersectObjects(candidateMeshes);

        if (intersects.length > 0) {
            // We hit something
            const hitObj = intersects[0].object;
            const bot = hitObj.userData.parent;
            if (bot && bot.active) {
                bot.hit(hitObj.userData.type);
                
                // Create hit spark
                createSpark(intersects[0].point, intersects[0].face.normal);
            }
        }

        updateHUD();
    }

    function reload() {
        // Simple instant reload for arcade feel
        GAME.ammo = CONFIG.weapon.ammo;
        updateHUD();
        // Animate weapon dip
        weaponGroup.rotation.x = -1;
        setTimeout(() => weaponGroup.rotation.x = 0, 200);
    }

    // Visual Effects
    function createSpark(pos, normal) {
        const geo = new THREE.BufferGeometry();
        const mat = new THREE.PointsMaterial({ color: 0xffff00, size: 0.1 });
        const particleCount = 5;
        // Simple temporary particles (simplified for single file)
        // For efficiency, just flashing the bot is implemented in Bot.hit
    }

    function showKillMsg(text, isHeadshot) {
        const feed = document.getElementById('kill-feed');
        const el = document.createElement('div');
        el.className = 'kill-msg ' + (isHeadshot ? 'headshot' : 'bodyshot');
        el.innerText = text;
        feed.appendChild(el);
        
        // Animation
        setTimeout(() => { el.style.opacity = 0; el.style.transform = 'translateY(-20px)'; }, 500);
        setTimeout(() => { el.remove(); }, 1500);
    }

    function onKeyDown(e) {
        switch (e.code) {
            case 'ArrowUp':
            case 'KeyW': moveState.forward = true; break;
            case 'ArrowLeft':
            case 'KeyA': moveState.left = true; break;
            case 'ArrowDown':
            case 'KeyS': moveState.backward = true; break;
            case 'ArrowRight':
            case 'KeyD': moveState.right = true; break;
            case 'KeyR': reload(); break;
        }
    }

    function onKeyUp(e) {
        switch (e.code) {
            case 'ArrowUp':
            case 'KeyW': moveState.forward = false; break;
            case 'ArrowLeft':
            case 'KeyA': moveState.left = false; break;
            case 'ArrowDown':
            case 'KeyS': moveState.backward = false; break;
            case 'ArrowRight':
            case 'KeyD': moveState.right = false; break;
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function updateHUD() {
        document.getElementById('score').innerText = GAME.score;
        document.getElementById('ammo-count').innerText = `${GAME.ammo} / ∞`;
        document.getElementById('timer').innerText = Math.ceil(GAME.timeLeft);
        
        if(GAME.timeLeft <= 10) {
            document.getElementById('timer').style.color = '#ff4655';
        } else {
            document.getElementById('timer').style.color = 'white';
        }
    }

    // --- Main Loop ---
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    function animate() {
        const time = performance.now();
        const delta = (time - GAME.lastTime) / 1000;
        GAME.lastTime = time;

        if (GAME.state === 'playing') {
            // Update Timer
            GAME.timeLeft -= delta;
            updateHUD();
            if (GAME.timeLeft <= 0) {
                gameOver();
                return;
            }

            // Player Movement
            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.normalize(); // consistent speed

                if (moveState.forward || moveState.backward) velocity.z -= direction.z * 400.0 * delta;
                if (moveState.left || moveState.right) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
            }

            // Weapon Animation (Return to position)
            weaponGroup.position.z += ( -0.5 - weaponGroup.position.z ) * 10 * delta;
        }

        // Update Bots
        // Filter dead bots
        GAME.targets = GAME.targets.filter(bot => bot.active);
        GAME.targets.forEach(bot => bot.update(delta));

        renderer.render(scene, camera);
    }

    initGame();

</script>
</body>
</html>
