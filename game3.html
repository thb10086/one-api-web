<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>霓虹深渊：觉醒 (Ver 8.1 修复版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary: #00f3ff;
            --secondary: #ff00ff;
            --warning: #ffaa00;
            --danger: #ff0055;
            --bg: #000000;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--bg); overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            user-select: none; touch-action: none; color: white;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* Effects Layer */
        #fx-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            transition: opacity 0.3s; opacity: 0;
        }
        .fx-time-stop {
            background: linear-gradient(135deg, rgba(0,255,255,0.1), rgba(0,0,50,0.2));
            box-shadow: inset 0 0 100px var(--primary);
            backdrop-filter: brightness(1.2) contrast(1.1);
            opacity: 1 !important;
        }
        .fx-ult {
            background: rgba(255, 50, 0, 0.2);
            animation: shake 0.5s infinite;
            opacity: 1 !important;
        }

        @keyframes shake {
            0% { transform: translate(0,0); } 25% { transform: translate(2px,-2px); }
            50% { transform: translate(-2px,2px); } 75% { transform: translate(2px,2px); } 100% { transform: translate(0,0); }
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            z-index: 20;
        }

        /* Top Bar */
        .top-bar {
            padding: 40px 20px 10px 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: auto;
        }

        .xp-bar-fixed {
            position: fixed; top: 0; left: 0; width: 100%; height: 8px; 
            background: #111; z-index: 100;
            box-shadow: 0 0 10px var(--primary);
        }
        .xp-fill {
            height: 100%; background: linear-gradient(90deg, #00f3ff, #ff00ff); 
            width: 0%; transition: width 0.2s; 
            box-shadow: 0 0 20px var(--primary);
        }

        .hp-container {
            position: relative; width: 240px; height: 24px;
            background: rgba(20,20,20,0.8); border: 1px solid #666; transform: skewX(-20deg);
            margin-bottom: 8px;
        }
        .hp-fill {
            height: 100%; background: linear-gradient(90deg, #ff0055, #ff5555); 
            width: 100%; transition: width 0.1s;
            box-shadow: 0 0 15px var(--danger);
        }
        .hp-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 11px; font-weight: 900; color: white; transform: skewX(20deg);
            text-shadow: 1px 1px 2px black;
        }

        /* Boss HP */
        #boss-hp-container {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 25px; background: rgba(0,0,0,0.8); border: 2px solid var(--danger);
            display: none; z-index: 20; box-shadow: 0 0 30px rgba(255,0,0,0.4);
        }
        #boss-hp-fill {
            height: 100%; background: linear-gradient(90deg, #880000, #ff0000); width: 100%; transition: width 0.2s;
        }
        #boss-name {
            position: absolute; top: -35px; left: 0; width: 100%; text-align: center;
            color: var(--danger); font-weight: 900; font-size: 1.8rem; 
            text-shadow: 0 0 20px red; letter-spacing: 3px;
        }

        /* Controls */
        .skill-btn {
            position: absolute; bottom: 50px; right: 40px; width: 85px; height: 85px;
            border-radius: 50%; border: 2px solid var(--primary); 
            background: rgba(0,20,30,0.5); backdrop-filter: blur(5px);
            display: flex; align-items: center; justify-content: center; font-size: 32px;
            box-shadow: 0 0 20px var(--primary); pointer-events: auto;
            transition: transform 0.1s;
        }
        .skill-btn:active { transform: scale(0.9); }
        .skill-cd-mask {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); clip-path: circle(0% at 50% 50%);
        }

        .ult-btn {
            position: absolute; bottom: 160px; right: 52px; width: 60px; height: 60px;
            border-radius: 50%; border: 2px solid var(--warning); background: rgba(255, 170, 0, 0.2);
            display: none; align-items: center; justify-content: center; font-size: 24px;
            box-shadow: 0 0 40px var(--warning); pointer-events: auto; animation: pulseUlt 1s infinite;
            z-index: 60; cursor: pointer;
        }
        @keyframes pulseUlt { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        
        .ult-bar-container {
            position: absolute; bottom: 150px; right: 42px; width: 80px; height: 6px; 
            background: #222; border: 1px solid #444; border-radius: 3px;
        }
        .ult-bar-fill { height: 100%; background: var(--warning); width: 0%; transition: width 0.2s; }

        /* Menus */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); backdrop-filter: blur(15px);
            display: none; justify-content: center; align-items: center; flex-direction: column;
            z-index: 100; pointer-events: auto;
        }

        .btn {
            background: transparent; color: white; border: 2px solid white; padding: 15px 50px;
            font-size: 1.5rem; font-family: 'Orbitron'; font-weight: 900;
            cursor: pointer; transition: 0.2s; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            margin: 15px; text-transform: uppercase;
            text-shadow: 0 0 10px white; box-shadow: 0 0 15px rgba(255,255,255,0.2);
        }
        .btn:hover { background: white; color: black; transform: scale(1.05); box-shadow: 0 0 40px white; }

        .reroll-btn {
            margin-top: 20px; background: rgba(0,0,0,0.5); border: 1px solid #666; color: #aaa;
            padding: 10px 30px; font-size: 1rem; border-radius: 4px;
        }
        .reroll-btn:hover { border-color: var(--warning); color: var(--warning); }

        .grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;
            padding: 20px; max-width: 1200px; width: 95%;
        }
        @media(max-width: 768px) { .grid { grid-template-columns: 1fr; overflow-y: auto; max-height: 70vh; } }

        .card {
            background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
            border: 1px solid #444; border-radius: 8px; padding: 25px;
            cursor: pointer; position: relative; overflow: hidden;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            transition: all 0.2s; min-height: 260px; justify-content: space-between;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        .card:hover { transform: translateY(-5px); border-color: white; box-shadow: 0 10px 40px rgba(255,255,255,0.1); }
        .card.rare { border-top: 4px solid var(--primary); }
        .card.legendary { border-top: 4px solid var(--warning); }
        
        .card h3 { font-size: 1.4rem; margin-bottom: 10px; font-weight: bold; }
        .card .desc { color: #ccc; font-size: 0.9rem; line-height: 1.6; }
        .card .level-tag { background: #000; padding: 5px 15px; border: 1px solid #444; border-radius: 20px; font-size: 0.8rem; color: #fff; margin-top: 15px; }

    </style>
</head>
<body>

    <div class="xp-bar-fixed"><div class="xp-fill" id="xp-bar"></div></div>

    <canvas id="gameCanvas"></canvas>
    <!-- Visual Effect Layer -->
    <div id="fx-layer"></div>

    <div id="ui-layer">
        <div class="top-bar">
            <div>
                <div class="hp-container">
                    <div class="hp-fill" id="hp-bar"></div>
                    <div class="hp-text"><span id="hp-val">100</span> / <span id="hp-max">100</span></div>
                </div>
                <div style="font-size:1rem; color: #aaa; font-weight:bold; margin-left: 5px;">
                    LV <span id="lvl-txt" style="color:var(--primary); font-size:1.2rem;">1</span>
                    <span style="margin: 0 10px; opacity:0.3">|</span> 
                    KILL <span id="kill-txt" style="color:white;">0</span>
                </div>
            </div>
            <div style="text-align:right;">
                <div style="font-size:2rem; font-weight:900; color: #fff; text-shadow: 0 0 15px var(--primary);" id="time-txt">00:00</div>
                <button class="btn" style="padding: 5px 15px; font-size:0.8rem; margin:5px 0 0 0; border-width:1px;" onclick="Game.togglePause()">PAUSE</button>
            </div>
        </div>

        <div id="boss-hp-container">
            <div id="boss-name">BOSS</div>
            <div id="boss-hp-fill"></div>
        </div>
        
        <div class="ult-bar-container"><div class="ult-bar-fill" id="ult-bar"></div></div>
        <div class="ult-btn" id="ult-btn">☢</div>

        <div class="skill-btn" id="dash-btn">
            ⏩
            <div class="skill-cd-mask" id="dash-cd"></div>
        </div>
    </div>

    <!-- Menus -->
    <div id="start-menu" class="modal" style="display:flex;">
        <h1 style="font-size: 4rem; margin-bottom: 10px; color: var(--primary); text-shadow: 0 0 40px var(--primary); text-align:center; line-height: 1;">NEON<br><span style="color:white; font-size:2rem; letter-spacing: 5px;">ABYSS 8.1</span></h1>
        <p style="color:#888; margin-bottom:40px; font-size: 1rem;">系统修复 • 稳定连接 • 极致打击</p>
        <button class="btn" onclick="Game.start()">开始任务</button>
    </div>

    <div id="upgrade-menu" class="modal">
        <h2 style="color:white; margin-bottom:30px; font-size: 2.5rem; text-shadow: 0 0 20px white;">选择强化</h2>
        <div class="grid" id="card-grid"></div>
        <button class="btn reroll-btn" id="reroll-btn" onclick="Upgrades.reroll()">重置数据 (3)</button>
    </div>

    <div id="game-over" class="modal">
        <h1 style="color:var(--danger); font-size:3.5rem; margin-bottom: 20px; text-shadow: 0 0 30px var(--danger);">连接中断</h1>
        <p style="font-size: 1.5rem; color: #fff;">存活时间: <span id="final-time" style="color:var(--primary); font-weight:bold;"></span></p>
        <p style="font-size: 1.2rem; color: #aaa;">击杀数量: <span id="final-kills"></span></p>
        <button class="btn" onclick="location.reload()">重新连接</button>
    </div>

    <script>
    (function() {
        // --- AUDIO ENGINE ---
        const Sfx = {
            ctx: null,
            init() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.25; 
                this.master.connect(this.ctx.destination);
            },
            play(type) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                if (type === 'shoot') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(300 + Math.random()*50, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                    gain.gain.setValueAtTime(0.08, t); gain.gain.linearRampToValueAtTime(0, t + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'square'; osc.frequency.setValueAtTime(150, t); osc.frequency.linearRampToValueAtTime(50, t + 0.05);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.05);
                } else if (type === 'dash') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(100, t + 0.3);
                    gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
                } else if (type === 'level') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(800, t+0.4);
                    gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.6);
                } else if (type === 'ult') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(1000, t + 2);
                    gain.gain.setValueAtTime(0.4, t); gain.gain.linearRampToValueAtTime(0, t + 2);
                }

                osc.connect(gain); gain.connect(this.master);
                osc.start(); osc.stop(t + 2);
            }
        };

        // --- BACKGROUND FX ---
        class Starfield {
            constructor() {
                this.stars = [];
                for(let i=0; i<150; i++) {
                    this.stars.push({
                        x: Math.random() * window.innerWidth,
                        y: Math.random() * window.innerHeight,
                        size: Math.random() * 2,
                        speed: Math.random() * 0.5 + 0.1
                    });
                }
            }
            update(dx, dy) {
                this.stars.forEach(s => {
                    s.x -= dx * s.speed;
                    s.y -= dy * s.speed;
                    if(s.x < 0) s.x = window.innerWidth;
                    if(s.x > window.innerWidth) s.x = 0;
                    if(s.y < 0) s.y = window.innerHeight;
                    if(s.y > window.innerHeight) s.y = 0;
                });
            }
            draw(ctx) {
                ctx.fillStyle = '#fff';
                this.stars.forEach(s => {
                    ctx.globalAlpha = Math.random() * 0.3 + 0.1;
                    ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
        }

        // --- GAME ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let cw, ch;
        function resize() { cw = canvas.width = window.innerWidth; ch = canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

        const Game = {
            active: false, paused: false,
            time: 0, frame: 0, score: 0,
            
            player: null,
            enemies: [], eBullets: [], bullets: [], particles: [], pickups: [], texts: [],
            lasers: [], novas: [],
            
            bossActive: null,
            timeStopActive: false, timeStopDuration: 0,
            waveConfig: { nextSwarm: 15, bossSpawned: false },
            
            starfield: null,

            start() {
                Sfx.init();
                document.getElementById('start-menu').style.display = 'none';
                this.active = true;
                this.player = new Player();
                this.starfield = new Starfield();
                this.reset();
                this.loop();
                if(this.timer) clearInterval(this.timer);
                this.timer = setInterval(() => {
                    if(!this.paused && this.active && !Game.timeStopActive) {
                        Game.time++; // Use Game.time instead of this.time for safety
                        Game.updateTimeDisplay();
                    }
                }, 1000);
            },

            reset() {
                this.enemies = []; this.eBullets = []; this.bullets = [];
                this.particles = []; this.pickups = []; this.texts = []; this.lasers = []; this.novas = [];
                this.time = 0; this.score = 0; this.frame = 0;
                this.timeStopActive = false; this.bossActive = null;
                this.waveConfig = { nextSwarm: 15, bossSpawned: false };
                document.getElementById('boss-hp-container').style.display = 'none';
                document.getElementById('fx-layer').className = ''; 
                Upgrades.rerolls = 3;
            },

            togglePause() {
                if(!this.active) return;
                this.paused = !this.paused;
                document.getElementById('pause-menu').style.display = this.paused ? 'flex' : 'none';
            },

            over() {
                this.active = false;
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('final-time').innerText = document.getElementById('time-txt').innerText;
                document.getElementById('final-kills').innerText = this.score;
            },

            updateTimeDisplay() {
                const m = Math.floor(Game.time/60).toString().padStart(2,'0');
                const s = (Game.time%60).toString().padStart(2,'0');
                document.getElementById('time-txt').innerText = `${m}:${s}`;
            },

            triggerUlt() {
                if(Game.player.ultCharge < 100) return;
                Game.player.ultCharge = 0;
                Game.player.ultActive = true;
                Game.player.ultTimer = 300; 
                document.getElementById('ult-btn').style.display = 'none';
                document.getElementById('fx-layer').className = 'fx-ult';
                setTimeout(() => { if(!Game.timeStopActive) document.getElementById('fx-layer').className = ''; }, 500);
                Sfx.play('dash'); 
                
                Game.enemies.forEach(e => {
                    if(e.type !== 'boss') e.hit(9999, 0, 0, true);
                    else e.hit(1000, 0, 0, true);
                });
            },

            activateTimeStop(duration) {
                Game.timeStopActive = true;
                Game.timeStopDuration = duration;
                document.getElementById('fx-layer').className = 'fx-time-stop';
                Game.texts.push(new Text("TIME STOP", Game.player.x, Game.player.y - 80, 40, '#00ffff'));
            },

            loop() {
                if(!Game.active) return;
                requestAnimationFrame(Game.loop);
                if(Game.paused) return;
                Game.frame++;

                // BG CLEAR
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; 
                ctx.fillRect(0, 0, cw, ch);

                // Starfield
                if(Game.starfield && Game.player) {
                    Game.starfield.update(0, 0); 
                    Game.starfield.draw(ctx);
                }

                // Update Logic
                Director.update(Game.time, Game.frame);

                // BUG FIX: Access Game property explicitly, NOT using 'this'
                if (Game.timeStopActive) {
                    Game.timeStopDuration--;
                    if(Game.timeStopDuration <= 0) {
                        Game.timeStopActive = false;
                        document.getElementById('fx-layer').className = '';
                    }
                }

                Game.player.update();
                Game.player.draw();

                [Game.bullets, Game.eBullets, Game.enemies, Game.pickups, Game.particles, Game.texts, Game.lasers, Game.novas].forEach(arr => {
                    for(let i = arr.length-1; i>=0; i--) {
                        arr[i].update();
                        arr[i].draw();
                        if(arr[i].dead) arr.splice(i, 1);
                    }
                });

                // UI Updates
                const cdPct = Game.player.dashCd / Game.player.maxDashCd;
                document.getElementById('dash-cd').style.clipPath = `circle(${cdPct * 100}% at 50% 50%)`;
                
                const ultPct = Math.min(100, Game.player.ultCharge);
                document.getElementById('ult-bar').style.width = ultPct + '%';
                if(ultPct >= 100) document.getElementById('ult-btn').style.display = 'flex';

                if(Game.bossActive && !Game.bossActive.dead) {
                    document.getElementById('boss-hp-fill').style.width = (Game.bossActive.hp / Game.bossActive.maxHp * 100) + '%';
                }
            }
        };
        window.Game = Game;

        // --- CLASSES ---

        class Player {
            constructor() {
                this.x = cw/2; this.y = ch/2;
                this.r = 12;
                this.stats = {
                    hp: 100, maxHp: 100, speed: 5, dmg: 15, fireRate: 20, count: 1, 
                    pierce: 0, magnet: 150, critRate: 0.05, critDmg: 2.0
                };
                this.skills = { homing: 0, explosive: 0, laser: 0, timeStop: 0, multiShot: 0, nova: 0, crit: 0 };
                this.dashCd = 0; this.maxDashCd = 60; 
                this.dashing = false; this.dashTime = 0;
                this.xp = 0; this.lvl = 1; this.nextXp = 30;
                
                this.shootTimer = 0; this.laserTimer = 0; this.timeStopTimer = 0; this.novaTimer = 0;
                this.ultCharge = 0; this.ultActive = false; this.ultTimer = 0;
            }

            update() {
                // Movement
                let dx = 0, dy = 0;
                if(Input.keys['w']) dy = -1; if(Input.keys['s']) dy = 1;
                if(Input.keys['a']) dx = -1; if(Input.keys['d']) dx = 1;
                if(Input.touch.active) {
                    dx = (Input.touch.currX - Input.touch.startX)/60;
                    dy = (Input.touch.currY - Input.touch.startY)/60;
                }
                
                if(this.dashCd > 0) this.dashCd--;
                if((Input.keys[' '] || Input.touch.dash) && this.dashCd <= 0) {
                    this.dashing = true; this.dashTime = 10; this.dashCd = this.maxDashCd;
                    Input.touch.dash = false;
                    Sfx.play('dash');
                    // Dash particles
                    for(let i=0; i<6; i++) Game.particles.push(new Particle(this.x, this.y, '#00ffff', 3));
                }

                let speed = this.stats.speed;
                if(this.dashing) { speed *= 2.5; this.dashTime--; if(this.dashTime <= 0) this.dashing = false; }
                
                const dist = Math.hypot(dx, dy);
                if(dist > 1) { dx/=dist; dy/=dist; }
                this.x += dx * speed; this.y += dy * speed;
                this.x = Math.max(15, Math.min(cw-15, this.x)); this.y = Math.max(15, Math.min(ch-15, this.y));

                // Starfield interaction (Simulated)
                if(Game.starfield) Game.starfield.update(dx*speed, dy*speed);

                // Skills
                if(this.skills.laser > 0) {
                    const cd = Math.max(40, 180 - (this.skills.laser * 25));
                    if(++this.laserTimer >= cd) {
                        const t = this.getClosestEnemy();
                        if(t) {
                            Game.lasers.push(new Laser(this.x, this.y, t.x, t.y, this.skills.laser));
                            this.laserTimer = 0;
                        }
                    }
                }
                if(this.skills.timeStop > 0) {
                    const cd = 900; 
                    if(++this.timeStopTimer >= cd) {
                        Game.activateTimeStop(120 + (this.skills.timeStop * 30));
                        this.timeStopTimer = 0;
                    }
                }
                if(this.skills.nova > 0) {
                    const cd = 120;
                    if(++this.novaTimer >= cd) {
                        Game.novas.push(new Nova(this.x, this.y, this.skills.nova));
                        this.novaTimer = 0;
                    }
                }

                // Shoot
                this.shootTimer++;
                const fireRate = this.ultActive ? 4 : Math.max(5, this.stats.fireRate);
                if(this.shootTimer >= fireRate) {
                    const target = this.getClosestEnemy();
                    if(target) {
                        this.shoot(target, this.ultActive);
                        this.shootTimer = 0;
                    }
                }

                // Magnet
                Game.pickups.forEach(p => {
                    const d = Math.hypot(p.x - this.x, p.y - this.y);
                    if(d < this.stats.magnet) { p.x += (this.x-p.x)*0.2; p.y += (this.y-p.y)*0.2; }
                    if(d < this.r + p.r) p.collect();
                });

                // Ult Timer
                if(this.ultActive) {
                    this.ultTimer--;
                    if(this.ultTimer <= 0) {
                        this.ultActive = false;
                        if(!Game.timeStopActive) document.getElementById('fx-layer').className = '';
                    }
                }
            }

            getClosestEnemy() {
                let close = null; let minD = Infinity;
                Game.enemies.forEach(e => {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if(d < minD) { minD = d; close = e; }
                });
                return close;
            }

            shoot(target, rapid=false) {
                if(!rapid) Sfx.play('shoot');
                const baseAngle = Math.atan2(target.y - this.y, target.x - this.x);
                const cnt = this.stats.count + this.skills.multiShot;
                for(let i=0; i<cnt; i++) {
                    const spread = cnt > 1 ? (i/(cnt-1)-0.5)*0.3 : 0;
                    Game.bullets.push(new Bullet(this.x, this.y, baseAngle+spread, this.skills, this.stats));
                }
            }

            hit(dmg) {
                if(this.dashing || this.ultActive) return;
                this.stats.hp -= dmg;
                const pct = Math.max(0, this.stats.hp / this.stats.maxHp * 100);
                document.getElementById('hp-bar').style.width = pct + '%';
                document.getElementById('hp-val').innerText = Math.floor(this.stats.hp);
                
                // Screen shake
                
                if(this.stats.hp <= 0) Game.over();
            }

            gainXp(amt) {
                this.xp += amt;
                this.ultCharge = Math.min(100, this.ultCharge + (amt/4));

                if(this.xp >= this.nextXp) {
                    this.xp -= this.nextXp;
                    this.lvl++;
                    this.nextXp = Math.floor(30 + (this.lvl * 25) * 1.2);
                    document.getElementById('lvl-txt').innerText = this.lvl;
                    Sfx.play('level');
                    Upgrades.show();
                    const heal = this.stats.maxHp * 0.2;
                    this.stats.hp = Math.min(this.stats.maxHp, this.stats.hp + heal);
                    document.getElementById('hp-bar').style.width = (this.stats.hp/this.stats.maxHp*100) + '%';
                    document.getElementById('hp-val').innerText = Math.floor(this.stats.hp);
                }
                document.getElementById('xp-bar').style.width = (this.xp/this.nextXp*100)+'%';
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 20; ctx.shadowColor = this.ultActive ? '#ffaa00' : '#0ff';
                ctx.fillStyle = this.ultActive ? '#fff' : '#000';
                ctx.strokeStyle = this.ultActive ? '#ffaa00' : '#0ff'; ctx.lineWidth = 3;
                
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                // Core
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class Enemy {
            constructor(type, config) {
                const angle = Math.random() * Math.PI * 2;
                const d = Math.max(cw, ch) * 0.7 + Math.random()*200;
                this.x = Game.player.x + Math.cos(angle) * d;
                this.y = Game.player.y + Math.sin(angle) * d;
                this.type = type;
                
                const timeFactor = 1 + (Game.time / 300);
                const lvlFactor = 1 + (Game.player.lvl * 0.05);
                
                this.hp = config.hp * timeFactor * lvlFactor;
                this.maxHp = this.hp;
                this.sp = config.sp;
                this.xp = config.xp;
                this.col = config.col;
                this.r = config.r || 15;
                this.dmg = config.dmg || 5;
                
                this.pushX = 0; this.pushY = 0;
                this.frozen = 0;
                this.hitFlash = 0;
                
                if(type === 'boss') {
                    this.x = Game.player.x; this.y = Game.player.y - 500;
                    this.name = config.name;
                    this.state = 'idle'; this.timer = 0;
                    Game.bossActive = this;
                    
                    const ui = document.getElementById('boss-hp-container');
                    ui.style.display = 'block';
                    document.getElementById('boss-name').innerText = this.name.toUpperCase();
                }
            }

            update() {
                if (this.hitFlash > 0) this.hitFlash--;
                // Time Stop affects non-bosses completely
                if (Game.timeStopActive && this.type !== 'boss') return; 
                if (this.frozen > 0) { this.frozen--; return; }

                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const dist = Math.hypot(dx, dy);
                const angle = Math.atan2(dy, dx);

                if (this.type === 'shooter') {
                    if (dist > 350) { this.x += Math.cos(angle) * this.sp; this.y += Math.sin(angle) * this.sp; }
                    else if (dist < 200) { this.x -= Math.cos(angle) * this.sp; this.y -= Math.sin(angle) * this.sp; }
                    if (Game.frame % 120 === 0 && dist < 700) Game.eBullets.push(new EnemyBullet(this.x, this.y, angle, 6));
                }
                else if (this.type === 'boss') {
                    this.updateBoss(dist, angle);
                }
                else {
                    this.x += Math.cos(angle) * this.sp;
                    this.y += Math.sin(angle) * this.sp;
                }

                this.x += this.pushX; this.y += this.pushY;
                this.pushX *= 0.9; this.pushY *= 0.9;

                if (dist < this.r + Game.player.r) {
                    Game.player.hit(this.dmg);
                    this.pushX = -Math.cos(angle) * 10;
                    this.pushY = -Math.sin(angle) * 10;
                }
            }

            updateBoss(dist, angle) {
                this.timer++;
                if(this.state === 'idle') {
                    this.x += Math.cos(angle) * (this.sp * 0.5); 
                    this.y += Math.sin(angle) * (this.sp * 0.5);
                    if(this.timer > 100) {
                        const rand = Math.random();
                        if(rand < 0.4) this.state = 'charge';
                        else if(rand < 0.7) this.state = 'barrage';
                        else this.state = 'summon';
                        this.timer = 0;
                    }
                }
                else if(this.state === 'charge') {
                    if(this.timer > 40 && this.timer < 70) {
                        this.x += Math.cos(angle) * (this.sp * 4);
                        this.y += Math.sin(angle) * (this.sp * 4);
                    }
                    if(this.timer > 90) { this.state = 'idle'; this.timer = 0; }
                }
                else if(this.state === 'barrage') {
                    if(this.timer % 5 === 0) {
                        const offset = (this.timer/5) * 0.2;
                        for(let i=0; i<5; i++) Game.eBullets.push(new EnemyBullet(this.x, this.y, (Math.PI*2/5)*i + offset, 5));
                    }
                    if(this.timer > 60) { this.state = 'idle'; this.timer = 0; }
                }
                else if(this.state === 'summon') {
                    if(this.timer === 30) for(let i=0; i<3; i++) Game.enemies.push(new Enemy('fast', Director.types.fast));
                    if(this.timer > 50) { this.state = 'idle'; this.timer = 0; }
                }
            }

            hit(dmg, kx, ky, isCrit) {
                this.hp -= dmg;
                const resist = (this.type === 'boss' ? 0.1 : (this.type === 'tank' ? 0.3 : 1.0));
                this.pushX = kx * 2 * resist; 
                this.pushY = ky * 2 * resist;
                this.hitFlash = 3; 
                
                if(!Game.player.ultActive) Sfx.play('hit');
                Game.texts.push(new Text(Math.floor(dmg), this.x, this.y - this.r, isCrit ? 24 : 14, isCrit ? '#ff0000' : '#fff'));

                if(this.hp <= 0 && !this.dead) {
                    this.dead = true;
                    if(this.type !== 'boss') {
                        Game.score++;
                        document.getElementById('kill-txt').innerText = Game.score;
                        Game.pickups.push(new Pickup(this.x, this.y, this.xp));
                    }
                    
                    // Improved explosion
                    for(let i=0; i<8; i++) Game.particles.push(new Particle(this.x, this.y, this.col, 4));

                    if(this.type === 'boss') {
                        Game.texts.push(new Text("VICTORY!", this.x, this.y, 50, '#ffd700'));
                        Game.bossActive = null;
                        Game.waveConfig.bossSpawned = false;
                        document.getElementById('boss-hp-container').style.display = 'none';
                        Game.player.gainXp(1000);
                        Game.eBullets = [];
                    }
                }
            }

            draw() {
                // Better visual distinction for frozen enemies
                if(Game.timeStopActive && this.type!=='boss') ctx.globalAlpha = 0.5;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if(this.hitFlash > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 30; ctx.shadowColor = '#fff';
                } else if(this.frozen > 0) {
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowBlur = 10; ctx.shadowColor = '#00ffff';
                } else {
                    ctx.fillStyle = this.col;
                    ctx.shadowBlur = 15; ctx.shadowColor = this.col;
                }
                
                if(this.type === 'boss') {
                    ctx.rotate(Game.frame * 0.05); ctx.fillRect(-this.r, -this.r, this.r*2, this.r*2);
                } else {
                    ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        // --- PROJECTILES & FX ---
        class Bullet {
            constructor(x, y, a, skills, stats) {
                this.x = x; this.y = y;
                this.vx = Math.cos(a)*12; this.vy = Math.sin(a)*12;
                this.life = 50; this.r = 5;
                this.skills = skills; this.stats = stats;
                this.hitList = [];
            }
            update() {
                if(this.skills.homing > 0) {
                    const t = Game.player.getClosestEnemy();
                    if(t) {
                        const idealA = Math.atan2(t.y-this.y, t.x-this.x);
                        const factor = 0.1 + (this.skills.homing * 0.05);
                        this.vx = this.vx * (1-factor) + Math.cos(idealA)*12*factor;
                        this.vy = this.vy * (1-factor) + Math.sin(idealA)*12*factor;
                    }
                }
                this.x += this.vx; this.y += this.vy;
                this.life--; if(this.life<=0) this.dead=true;

                for(let e of Game.enemies) {
                    if(this.hitList.includes(e)) continue;
                    if(Math.hypot(e.x-this.x, e.y-this.y) < e.r + this.r) {
                        let dmg = this.stats.dmg;
                        const isCrit = Math.random() < this.stats.critRate;
                        if(isCrit) dmg *= this.stats.critDmg;
                        if(this.skills.explosive > 0) dmg *= 1.2;

                        e.hit(dmg, this.vx/10, this.vy/10, isCrit);
                        this.hitList.push(e);

                        if(this.skills.explosive > 0) {
                            const range = 60 + (this.skills.explosive * 20);
                            for(let k=0; k<5; k++) Game.particles.push(new Particle(this.x, this.y, '#ffaa00', 3));
                            Game.enemies.forEach(sub => {
                                if(sub !== e && Math.hypot(sub.x-this.x, sub.y-this.y) < range) sub.hit(dmg*0.5, 0, 0, false);
                            });
                        }

                        if(this.stats.pierce <= 0) { this.dead = true; break; }
                        else this.stats.pierce--;
                    }
                }
            }
            draw() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter'; // GLOW!
                ctx.fillStyle = this.skills.explosive > 0 ? '#ffaa00' : '#fff';
                ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class EnemyBullet {
            constructor(x, y, a, spd) {
                this.x = x; this.y = y;
                this.vx = Math.cos(a)*spd; this.vy = Math.sin(a)*spd;
                this.r = 6; this.life = 120;
            }
            update() {
                if(Game.timeStopActive) return;
                this.x += this.vx; this.y += this.vy;
                this.life--; if(this.life<=0) this.dead=true;
                if(Math.hypot(Game.player.x-this.x, Game.player.y-this.y) < this.r + Game.player.r) {
                    Game.player.hit(10); this.dead=true;
                }
            }
            draw() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = '#f00'; ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class Laser {
            constructor(x, y, tx, ty, lvl) {
                this.sx = x; this.sy = y; this.tx = tx; this.ty = ty;
                this.life = 20; this.lvl = lvl;
                // Damage calculation
                const len = Math.hypot(tx-x, ty-y); const step = 20; const steps = len/step;
                const dx = (tx-x)/steps; const dy = (ty-y)/steps;
                for(let i=0; i<steps; i++) {
                    const cx = x + dx*i; const cy = y + dy*i;
                    Game.enemies.forEach(e => {
                        if(Math.hypot(e.x-cx, e.y-cy) < e.r + 20) e.hit(15*lvl, 0, 0, false);
                    });
                }
            }
            update() { this.life--; if(this.life<=0) this.dead=true; }
            draw() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = `rgba(0,255,255,${this.life/20})`; ctx.lineWidth = 15;
                ctx.shadowBlur = 20; ctx.shadowColor = '#0ff';
                ctx.beginPath(); ctx.moveTo(this.sx, this.sy); ctx.lineTo(this.tx, this.ty); ctx.stroke();
                ctx.lineWidth = 5; ctx.strokeStyle = '#fff'; ctx.stroke();
                ctx.restore();
            }
        }

        class Nova {
            constructor(x, y, lvl) {
                this.x = x; this.y = y; this.r = 0; this.maxR = 150 + (lvl*50);
                this.life = 40; this.lvl = lvl; this.hit = [];
            }
            update() {
                this.r += this.maxR/40; this.life--; if(this.life<=0) this.dead=true;
                Game.enemies.forEach(e => {
                    if(this.hit.includes(e)) return;
                    if(Math.hypot(e.x-this.x, e.y-this.y) < this.r + e.r) {
                        e.frozen = 60 + (this.lvl*30); e.hit(20*this.lvl, 0, 0, false); this.hit.push(e);
                    }
                });
            }
            draw() {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = `rgba(100,200,255,${this.life/40})`; ctx.lineWidth = 8;
                ctx.shadowBlur = 20; ctx.shadowColor = '#00ffff';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, c, s=1) {
                this.x = x; this.y = y; this.c = c;
                const a = Math.random()*Math.PI*2; const sp = Math.random()*3*s;
                this.vx = Math.cos(a)*sp; this.vy = Math.sin(a)*sp;
                this.life = 1;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.03; if(this.life<=0) this.dead=true; }
            draw() { 
                ctx.save();
                ctx.globalCompositeOperation = 'lighter'; 
                ctx.globalAlpha = this.life; ctx.fillStyle=this.c; 
                ctx.fillRect(this.x, this.y, 6, 6); 
                ctx.restore();
            }
        }

        class Pickup {
            constructor(x, y, v) { this.x=x; this.y=y; this.v=v; this.r=5; }
            update() {}
            collect() { this.dead=true; Game.player.gainXp(this.v); }
            draw() { 
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.shadowBlur = 10; ctx.shadowColor = '#0f0';
                ctx.fillStyle='#0f0'; ctx.beginPath(); ctx.rect(this.x-3,this.y-3,6,6); ctx.fill(); 
                ctx.restore();
            }
        }

        class Text {
            constructor(t, x, y, s=16, c='#fff') { this.t=t; this.x=x; this.y=y; this.s=s; this.c=c; this.life=40; }
            update() { this.y-=0.5; this.life--; if(this.life<=0) this.dead=true; }
            draw() { 
                ctx.save();
                ctx.globalAlpha=this.life/40; ctx.fillStyle=this.c; 
                ctx.font=`900 ${this.s}px Orbitron`; 
                ctx.shadowBlur = 5; ctx.shadowColor = this.c;
                ctx.fillText(this.t, this.x, this.y); 
                ctx.restore();
            }
        }

        // --- DIRECTOR ---
        const Director = {
            types: {
                basic: { hp:10, sp:1.8, xp:5, col:'#f0f', r:12, dmg:5 },
                fast: { hp:5, sp:3.5, xp:8, col:'#fa0', r:8, dmg:3 },
                tank: { hp:60, sp:0.8, xp:20, col:'#0f0', r:20, dmg:10 },
                shooter: { hp:12, sp:1.2, xp:10, col:'#f00', r:12, dmg:8 },
                kamikaze: { hp:8, sp:5.0, xp:12, col:'#ff5500', r:10, dmg:25 },
                elite: { hp:300, sp:1.5, xp:300, col:'#fff', r:30, dmg:15 }
            },
            bosses: [
                { time: 180, name: "Construct", hp: 5000, sp: 1.5, xp: 5000, col: '#f00' },
                { time: 360, name: "Devourer", hp: 12000, sp: 2.5, xp: 10000, col: '#ff5500' },
                { time: 600, name: "The End", hp: 50000, sp: 1.0, xp: 50000, col: '#fff' }
            ],
            
            update(time, frame) {
                const density = 1 + Math.floor(time / 60);
                
                if (frame % Math.max(10, 50 - density*2) === 0 && !Game.waveConfig.bossSpawned) {
                    const r = Math.random();
                    let type = 'basic';
                    if (time > 20 && r < 0.3) type = 'fast';
                    if (time > 45 && r < 0.15) type = 'shooter';
                    if (time > 60 && r < 0.1) type = 'kamikaze';
                    if (time > 90 && r < 0.1) type = 'tank';
                    
                    const count = time > 120 ? Math.ceil(Math.random() * density/2) : 1;
                    for(let i=0; i<count; i++) Game.enemies.push(new Enemy(type, this.types[type]));
                }

                if (time > 30 && time % 20 === 0 && frame % 60 === 0) this.swarm(10 + Math.floor(time/10));

                if ((time === 60 || (time > 120 && time % 60 === 0)) && frame % 60 === 0 && !Game.waveConfig.bossSpawned) {
                    Game.enemies.push(new Enemy('elite', this.types.elite));
                    Game.texts.push(new Text("⚠ ELITE ⚠", Game.player.x, Game.player.y-100, 30, '#fa0'));
                }

                const bossCfg = this.bosses.find(b => b.time === time);
                if (bossCfg && frame % 60 === 0 && !Game.waveConfig.bossSpawned) {
                    Game.enemies.push(new Enemy('boss', bossCfg));
                    Game.waveConfig.bossSpawned = true;
                    document.getElementById('boss-hp-container').style.display = 'block';
                }
            },
            swarm(count) {
                for(let i=0; i<count; i++) {
                    const a = (Math.PI*2/count)*i;
                    const e = new Enemy('basic', this.types.basic);
                    e.x = Game.player.x + Math.cos(a)*400; e.y = Game.player.y + Math.sin(a)*400;
                    Game.enemies.push(e);
                }
                Game.texts.push(new Text("⚠ SWARM ⚠", Game.player.x, Game.player.y-100, 40, '#f00'));
            }
        };

        // --- UPGRADES ---
        const Upgrades = {
            rerolls: 3,
            poolData: [
                { id:'dmg', name:'动能强化', desc:'伤害 +20%', rarity:'common', max:10, type:'mul', val:1.2 },
                { id:'fireRate', name:'极速射击', desc:'射速 +15%', rarity:'common', max:10, type:'mulInv', val:0.85 },
                { id:'count', name:'多重弹道', desc:'子弹数 +1', rarity:'rare', max:5, type:'add', val:1 },
                { id:'critRate', name:'致命节奏', desc:'暴击率 +10%', rarity:'rare', max:5, type:'add', val:0.1 },
                { id:'critDmg', name:'弱点识破', desc:'暴击伤害 +50%', rarity:'rare', max:5, type:'add', val:0.5 },
                { id:'homing', name:'智能追踪', desc:'子弹自动追踪敌人', rarity:'legendary', max:5, skill:true },
                { id:'explosive', name:'高爆弹头', desc:'子弹产生范围爆炸', rarity:'legendary', max:5, skill:true },
                { id:'laser', name:'轨道激光', desc:'周期性激光打击', rarity:'legendary', max:5, skill:true },
                { id:'timeStop', name:'时空力场', desc:'周期性冻结时间', rarity:'rare', max:5, skill:true },
                { id:'nova', name:'冰霜新星', desc:'周期性冻结周围', rarity:'rare', max:5, skill:true },
                { id:'hp', name:'应急治疗', desc:'恢复30%血量', rarity:'common', max:999, type:'heal' }
            ],
            
            show() {
                Game.paused = true;
                const menu = document.getElementById('upgrade-menu');
                const grid = document.getElementById('card-grid');
                document.getElementById('reroll-btn').innerText = `重置数据 (${this.rerolls})`;
                grid.innerHTML = '';

                let valid = this.poolData.filter(u => {
                    if(u.skill) return Game.player.skills[u.id] < u.max;
                    if(u.type !== 'heal') return true; 
                    return true;
                });

                const choices = [];
                for(let i=0; i<3; i++) {
                    if(valid.length === 0) break;
                    const idx = Math.floor(Math.random()*valid.length);
                    choices.push(valid[idx]);
                    if(valid[idx].rarity === 'legendary') valid.splice(idx, 1); 
                }

                choices.forEach(u => {
                    const el = document.createElement('div');
                    el.className = `card ${u.rarity}`;
                    
                    let curLvl = u.skill ? Game.player.skills[u.id] : 0;
                    let lvlTxt = u.skill ? `LV ${curLvl} ▶ ${curLvl+1}` : '通用强化';
                    if(u.type==='heal') lvlTxt = '即时生效';

                    el.innerHTML = `<h3>${u.name}</h3><div class="desc">${u.desc}</div><div class="level-tag">${lvlTxt}</div>`;
                    el.onclick = () => {
                        this.apply(u);
                        menu.style.display = 'none';
                        Game.paused = false;
                    };
                    grid.appendChild(el);
                });
                menu.style.display = 'flex';
            },

            apply(u) {
                const p = Game.player;
                if(u.skill) p.skills[u.id]++;
                else if(u.type === 'add') p.stats[u.id] += u.val;
                else if(u.type === 'mul') p.stats[u.id] *= u.val;
                else if(u.type === 'mulInv') p.stats[u.id] = Math.max(2, Math.floor(p.stats[u.id]*u.val));
                else if(u.type === 'heal') {
                    p.stats.hp = Math.min(p.stats.maxHp, p.stats.hp + (p.stats.maxHp*0.3));
                    document.getElementById('hp-bar').style.width = (p.stats.hp/p.stats.maxHp*100)+'%';
                }
            },

            reroll() {
                if(this.rerolls > 0) {
                    this.rerolls--;
                    this.show();
                }
            }
        };

        // --- CONTROLS ---
        const Input = { keys: {}, touch: { active:false, startX:0, startY:0, currX:0, currY:0, dash:false } };
        window.onkeydown = e => Input.keys[e.key] = true;
        window.onkeyup = e => Input.keys[e.key] = false;
        
        canvas.ontouchstart = e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            if(t.clientX < cw/2) {
                Input.touch.active = true;
                Input.touch.startX = Input.touch.currX = t.clientX;
                Input.touch.startY = Input.touch.currY = t.clientY;
            }
        };
        canvas.ontouchmove = e => {
            if(Input.touch.active) {
                const t = e.changedTouches[0];
                Input.touch.currX = t.clientX; Input.touch.currY = t.clientY;
            }
        };
        canvas.ontouchend = e => Input.touch.active = false;

        const dashBtn = document.getElementById('dash-btn');
        dashBtn.ontouchstart = (e) => { e.preventDefault(); Input.touch.dash = true; };
        dashBtn.onmousedown = (e) => { e.preventDefault(); Input.touch.dash = true; };
        
        const ultBtn = document.getElementById('ult-btn');
        ultBtn.ontouchstart = (e) => { e.preventDefault(); Game.triggerUlt(); };
        ultBtn.onmousedown = (e) => { e.preventDefault(); Game.triggerUlt(); };

    })();
    </script>
</body>
</html>
