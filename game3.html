<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>霓虹深渊：觉醒</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary: #00f3ff;
            --secondary: #ff00ff;
            --warning: #ffaa00;
            --danger: #ff0055;
            --bg: #050505;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--bg); overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            user-select: none; touch-action: none; color: white;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* FX Layers */
        #fx-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            transition: opacity 0.2s; opacity: 0;
        }
        .fx-time-stop {
            background: linear-gradient(135deg, rgba(0,255,255,0.1), rgba(0,0,50,0.2));
            box-shadow: inset 0 0 100px var(--primary);
            backdrop-filter: grayscale(100%) brightness(1.2);
            opacity: 1 !important;
        }
        .fx-ult {
            background: rgba(255, 50, 0, 0.2);
            animation: shake 0.5s infinite;
            opacity: 1 !important;
        }

        @keyframes shake {
            0% { transform: translate(0,0); } 25% { transform: translate(2px,-2px); }
            50% { transform: translate(-2px,2px); } 75% { transform: translate(2px,2px); } 100% { transform: translate(0,0); }
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            z-index: 20;
        }

        /* Top Bar */
        .top-bar {
            padding: 20px; /* Safe area padding usually handled by OS, keeping simple */
            padding-top: max(20px, env(safe-area-inset-top)); 
            display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: auto;
        }

        .xp-bar-fixed {
            position: fixed; top: 0; left: 0; width: 100%; height: 6px; 
            background: #111; z-index: 100;
            box-shadow: 0 0 15px var(--primary);
        }
        .xp-fill {
            height: 100%; background: linear-gradient(90deg, #00f3ff, #ff00ff); 
            width: 0%; transition: width 0.2s; 
            box-shadow: 0 0 20px var(--primary);
        }

        .hp-container {
            position: relative; width: 200px; height: 20px;
            background: rgba(20,20,20,0.8); border: 1px solid #666; transform: skewX(-15deg);
            margin-bottom: 5px;
        }
        .hp-fill {
            height: 100%; background: linear-gradient(90deg, #ff0055, #ff5555); 
            width: 100%; transition: width 0.1s;
            box-shadow: 0 0 15px var(--danger);
        }
        .hp-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; font-weight: 900; color: white; transform: skewX(15deg);
            text-shadow: 1px 1px 2px black;
        }

        /* Boss HP */
        #boss-hp-container {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 20px; background: rgba(0,0,0,0.8); border: 2px solid var(--danger);
            display: none; z-index: 20; box-shadow: 0 0 30px rgba(255,0,0,0.4);
        }
        #boss-hp-fill {
            height: 100%; background: linear-gradient(90deg, #880000, #ff0000); width: 100%; transition: width 0.2s;
        }
        #boss-name {
            position: absolute; top: -25px; left: 0; width: 100%; text-align: center;
            color: var(--danger); font-weight: 900; font-size: 1.2rem; 
            text-shadow: 0 0 20px red; letter-spacing: 2px;
        }

        /* Mobile Controls */
        .controls-area {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; flex-direction: column; align-items: flex-end;
            gap: 20px; padding-bottom: env(safe-area-inset-bottom);
        }

        .skill-btn {
            width: 90px; height: 90px;
            border-radius: 50%; border: 2px solid rgba(0, 243, 255, 0.5); 
            background: rgba(0, 20, 30, 0.6); backdrop-filter: blur(4px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 0 25px rgba(0, 243, 255, 0.2); 
            pointer-events: auto; overflow: hidden;
            transition: transform 0.1s, border-color 0.2s;
            /* Enhance touch target */
            position: relative;
        }
        .skill-btn:active { transform: scale(0.9); background: rgba(0, 243, 255, 0.2); border-color: #fff; }
        .skill-icon { font-size: 32px; z-index: 2; text-shadow: 0 0 10px var(--primary); pointer-events: none; }
        .skill-key { font-size: 10px; color: #aaa; margin-top: 2px; z-index: 2; font-weight: bold; pointer-events: none; }
        
        .skill-cd-overlay {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1; transition: height 0.1s linear; pointer-events: none;
        }

        .ult-btn {
            width: 70px; height: 70px; margin-right: 10px;
            border-radius: 50%; border: 2px solid var(--warning); background: rgba(255, 170, 0, 0.2);
            display: none; align-items: center; justify-content: center; font-size: 28px;
            box-shadow: 0 0 40px var(--warning); pointer-events: auto; animation: pulseUlt 1s infinite;
            z-index: 60; cursor: pointer; backdrop-filter: blur(4px);
        }
        @keyframes pulseUlt { 0% { transform: scale(1); box-shadow: 0 0 20px var(--warning); } 50% { transform: scale(1.1); box-shadow: 0 0 50px var(--warning); } 100% { transform: scale(1); box-shadow: 0 0 20px var(--warning); } }
        
        .ult-bar-container {
            width: 70px; height: 6px; margin-right: 10px; margin-bottom: -15px;
            background: #222; border: 1px solid #444; border-radius: 3px; z-index: 61;
        }
        .ult-bar-fill { height: 100%; background: var(--warning); width: 0%; transition: width 0.2s; box-shadow: 0 0 10px var(--warning); }

        /* Menus */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92); backdrop-filter: blur(10px);
            display: none; justify-content: center; align-items: center; flex-direction: column;
            z-index: 100; pointer-events: auto;
        }

        .btn {
            background: transparent; color: white; border: 2px solid rgba(0,243,255,0.5); padding: 15px 50px;
            font-size: 1.5rem; font-family: 'Orbitron'; font-weight: 900;
            cursor: pointer; transition: 0.2s;
            margin: 15px; text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .btn:hover { background: var(--primary); color: black; transform: scale(1.05); box-shadow: 0 0 40px var(--primary); border-color: #fff; }

        .reroll-btn {
            margin-top: 20px; background: rgba(0,0,0,0.5); border: 1px solid #666; color: #aaa;
            padding: 10px 30px; font-size: 1rem; border-radius: 4px;
        }
        .reroll-btn:hover { border-color: var(--warning); color: var(--warning); background: rgba(50,30,0,0.5); }

        .grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;
            padding: 20px; max-width: 1000px; width: 95%;
        }
        @media(max-width: 768px) { .grid { grid-template-columns: 1fr; overflow-y: auto; max-height: 70vh; } }

        .card {
            background: linear-gradient(145deg, #111, #1a1a2e);
            border: 1px solid #333; border-radius: 8px; padding: 20px;
            cursor: pointer; position: relative; overflow: hidden;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            transition: all 0.2s; min-height: 240px; justify-content: space-between;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        .card:hover { transform: translateY(-5px); border-color: white; background: #202035; box-shadow: 0 10px 40px rgba(0,243,255,0.15); }
        .card.rare { border-top: 3px solid var(--primary); }
        .card.legendary { border-top: 3px solid var(--warning); }
        
        .card h3 { font-size: 1.2rem; margin-bottom: 5px; font-weight: bold; color: #fff; }
        .card .desc { color: #bbb; font-size: 0.85rem; line-height: 1.4; }
        .card .level-tag { background: #000; padding: 3px 10px; border: 1px solid #444; border-radius: 10px; font-size: 0.75rem; color: #888; margin-top: 10px; }

    </style>
</head>
<body>

    <div class="xp-bar-fixed"><div class="xp-fill" id="xp-bar"></div></div>

    <canvas id="gameCanvas"></canvas>
    <div id="fx-layer"></div>

    <div id="ui-layer">
        <div class="top-bar">
            <div>
                <div class="hp-container">
                    <div class="hp-fill" id="hp-bar"></div>
                    <div class="hp-text"><span id="hp-val">100</span> / <span id="hp-max">100</span></div>
                </div>
                <div style="font-size:0.9rem; color: #888; font-weight:bold; margin-left: 5px;">
                    LV <span id="lvl-txt" style="color:var(--primary); font-size:1.1rem;">1</span>
                    <span style="margin: 0 10px; opacity:0.3">|</span> 
                    KILL <span id="kill-txt" style="color:#ddd;">0</span>
                </div>
            </div>
            <div style="text-align:right;">
                <div style="font-size:1.5rem; font-weight:900; color: #fff; text-shadow: 0 0 10px var(--primary);" id="time-txt">00:00</div>
                <button class="btn" style="padding: 5px 15px; font-size:0.7rem; margin:5px 0 0 0; border: 1px solid #555; box-shadow:none;" onclick="Game.togglePause()">PAUSE</button>
            </div>
        </div>

        <div id="boss-hp-container">
            <div id="boss-name">BOSS</div>
            <div id="boss-hp-fill"></div>
        </div>
        
        <div class="controls-area">
            <div class="ult-bar-container"><div class="ult-bar-fill" id="ult-bar"></div></div>
            <div class="ult-btn" id="ult-btn">☢</div>

            <div class="skill-btn" id="dash-btn">
                <span class="skill-icon">⚡</span>
                <span class="skill-key">DASH</span>
                <div class="skill-cd-overlay" id="dash-cd"></div>
            </div>
        </div>
    </div>

    <!-- Menus -->
    <div id="start-menu" class="modal" style="display:flex;">
        <h1 style="font-size: 3rem; margin-bottom: 5px; color: var(--primary); text-shadow: 0 0 40px var(--primary); text-align:center; line-height: 1;">NEON<br><span style="color:white; font-size:1.5rem; letter-spacing: 8px;">MOBILE 11.0</span></h1>
        <p style="color:#aaa; margin-bottom:40px; font-size: 0.9rem; text-shadow: 0 0 5px rgba(255,255,255,0.5);">滑屏移动 • 多点触控 • 沉浸体验</p>
        <button class="btn" onclick="Game.start()">建立神经连接</button>
    </div>

    <div id="pause-menu" class="modal">
        <h2 style="color:white; margin-bottom:30px; font-size: 3rem; text-shadow: 0 0 20px white; letter-spacing: 5px;">PAUSED</h2>
        <button class="btn" onclick="Game.togglePause()">继续连接</button>
        <button class="btn" style="border-color: var(--danger); color: var(--danger); box-shadow: 0 0 15px rgba(255,0,85,0.3);" onclick="location.reload()">断开连接</button>
    </div>

    <div id="upgrade-menu" class="modal">
        <h2 style="color:white; margin-bottom:20px; font-size: 2rem; text-shadow: 0 0 20px white;">选择强化回路</h2>
        <div class="grid" id="card-grid"></div>
        <button class="btn reroll-btn" id="reroll-btn" onclick="Upgrades.reroll()">重置信号 (3)</button>
    </div>

    <div id="game-over" class="modal">
        <h1 style="color:var(--danger); font-size:3rem; margin-bottom: 20px; text-shadow: 0 0 30px var(--danger);">信号丢失</h1>
        <p style="font-size: 1.2rem; color: #fff;">存活时间: <span id="final-time" style="color:var(--primary);"></span></p>
        <p style="font-size: 1rem; color: #aaa;">击杀数量: <span id="final-kills"></span></p>
        <button class="btn" onclick="location.reload()">重启系统</button>
    </div>

    <script>
    (function() {
        const Assets = {
            glows: {},
            init() {
                this.glows.cyan = this.createGlow(10, '#00f3ff');
                this.glows.red = this.createGlow(10, '#ff0055');
                this.glows.orange = this.createGlow(12, '#ffaa00');
                this.glows.white = this.createGlow(8, '#ffffff');
                this.glows.purple = this.createGlow(12, '#ff00ff');
                this.glows.green = this.createGlow(15, '#00ff00');
                this.glows.boss = this.createGlow(40, '#ff0000');
            },
            createGlow(r, color) {
                const c = document.createElement('canvas');
                const size = r * 6; c.width = size; c.height = size;
                const ctx = c.getContext('2d');
                const center = size / 2;
                const grad = ctx.createRadialGradient(center, center, r, center, center, size/2);
                grad.addColorStop(0, color); grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.globalAlpha = 0.6;
                ctx.beginPath(); ctx.arc(center, center, size/2, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 1.0; ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(center, center, r/2, 0, Math.PI*2); ctx.fill();
                return c;
            }
        };

        class Pool {
            constructor(createFn, resetFn) { this.pool = []; this.createFn = createFn; this.resetFn = resetFn; }
            get(...args) { let obj = this.pool.length > 0 ? this.pool.pop() : this.createFn(); this.resetFn(obj, ...args); return obj; }
            release(obj) { this.pool.push(obj); }
        }

        const Sfx = {
            ctx: null,
            init() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.2; this.master.connect(this.ctx.destination);
            },
            play(type) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                if (type === 'shoot') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(300, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'square'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(0, t + 0.05);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.05);
                } else if (type === 'dash') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(100, t + 0.3);
                    gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
                } else if (type === 'level') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(800, t+0.4);
                    gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.6);
                }
                osc.connect(gain); gain.connect(this.master); osc.start(); osc.stop(t + 1);
            }
        };

        class Starfield {
            constructor() {
                this.stars = [];
                for(let i=0; i<100; i++) this.stars.push({x:Math.random()*window.innerWidth, y:Math.random()*window.innerHeight, z:Math.random()*2+0.5});
            }
            update(dx, dy) {
                this.stars.forEach(s => {
                    s.x -= dx * s.z * 0.1; s.y -= dy * s.z * 0.1;
                    if(s.x < 0) s.x = window.innerWidth; else if(s.x > window.innerWidth) s.x = 0;
                    if(s.y < 0) s.y = window.innerHeight; else if(s.y > window.innerHeight) s.y = 0;
                });
            }
            draw(ctx) {
                ctx.fillStyle = '#fff';
                this.stars.forEach(s => { ctx.globalAlpha = 0.3; ctx.beginPath(); ctx.fillRect(s.x, s.y, s.z, s.z); });
                ctx.globalAlpha = 1;
            }
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let cw, ch;
        function resize() { cw = canvas.width = window.innerWidth; ch = canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

        const bulletPool = new Pool(() => new Bullet(), (b, x, y, a, skills, stats) => b.init(x, y, a, skills, stats));
        const particlePool = new Pool(() => new Particle(), (p, x, y, c, s) => p.init(x, y, c, s));
        const enemyPool = new Pool(() => new Enemy(), (e, type, cfg) => e.init(type, cfg));

        const Game = {
            active: false, paused: false,
            time: 0, frame: 0, score: 0,
            player: null, enemies: [], eBullets: [], bullets: [], particles: [], pickups: [], texts: [], lasers: [], novas: [],
            bossActive: null, timeStopActive: false, timeStopDuration: 0, waveConfig: { nextSwarm: 15, bossSpawned: false }, starfield: null,

            start() {
                Sfx.init(); Assets.init();
                document.getElementById('start-menu').style.display = 'none';
                this.active = true;
                this.player = new Player();
                this.starfield = new Starfield();
                this.reset();
                this.loop();
                if(this.timer) clearInterval(this.timer);
                this.timer = setInterval(() => {
                    if(!this.paused && this.active && !Game.timeStopActive) { Game.time++; Game.updateTimeDisplay(); }
                }, 1000);
            },

            reset() {
                this.enemies = []; this.eBullets = []; this.bullets = []; this.particles = []; this.pickups = []; this.texts = []; this.lasers = []; this.novas = [];
                this.time = 0; this.score = 0; this.frame = 0;
                this.timeStopActive = false; this.bossActive = null;
                this.waveConfig = { nextSwarm: 15, bossSpawned: false };
                document.getElementById('boss-hp-container').style.display = 'none';
                document.getElementById('fx-layer').className = ''; 
                Upgrades.rerolls = 3;
            },

            togglePause() {
                if(!this.active) return;
                this.paused = !this.paused;
                document.getElementById('pause-menu').style.display = this.paused ? 'flex' : 'none';
            },

            over() {
                this.active = false;
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('final-time').innerText = document.getElementById('time-txt').innerText;
                document.getElementById('final-kills').innerText = this.score;
            },

            updateTimeDisplay() {
                const m = Math.floor(Game.time/60).toString().padStart(2,'0');
                const s = (Game.time%60).toString().padStart(2,'0');
                document.getElementById('time-txt').innerText = `${m}:${s}`;
            },

            triggerUlt() {
                if(Game.player.ultCharge < 100) return;
                Game.player.ultCharge = 0; Game.player.ultActive = true; Game.player.ultTimer = 300; 
                document.getElementById('ult-btn').style.display = 'none';
                document.getElementById('fx-layer').className = 'fx-ult';
                setTimeout(() => { if(!Game.timeStopActive) document.getElementById('fx-layer').className = ''; }, 500);
                Sfx.play('dash'); 
                Game.enemies.forEach(e => { if(e.type !== 'boss') e.hit(9999, 0, 0, true); else e.hit(1000, 0, 0, true); });
            },

            activateTimeStop(duration) {
                Game.timeStopActive = true; Game.timeStopDuration = duration;
                document.getElementById('fx-layer').className = 'fx-time-stop';
                Game.texts.push(new Text("TIME STOP", Game.player.x, Game.player.y - 80, 40, '#00ffff'));
            },

            loop() {
                if(!Game.active) return;
                requestAnimationFrame(Game.loop);
                if(Game.paused) return;
                Game.frame++;

                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; ctx.fillRect(0, 0, cw, ch);

                if(Game.starfield && Game.player) { Game.starfield.update(0, 0); Game.starfield.draw(ctx); }

                Director.update(Game.time, Game.frame);

                if (Game.timeStopActive) {
                    Game.timeStopDuration--;
                    if(Game.timeStopDuration <= 0) { Game.timeStopActive = false; document.getElementById('fx-layer').className = ''; }
                }

                Game.player.update();

                ctx.globalCompositeOperation = 'lighter';
                const bImg = Assets.glows.cyan; const bOff = bImg.width / 2;
                for (let i = Game.bullets.length - 1; i >= 0; i--) {
                    let b = Game.bullets[i]; b.update();
                    if (b.dead) { bulletPool.release(b); Game.bullets.splice(i, 1); }
                    else ctx.drawImage(b.isExplosive ? Assets.glows.orange : bImg, b.x - bOff, b.y - bOff);
                }

                for (let i = Game.particles.length - 1; i >= 0; i--) {
                    let p = Game.particles[i]; p.update();
                    if (p.dead) { particlePool.release(p); Game.particles.splice(i, 1); }
                    else { ctx.globalAlpha = p.life; ctx.drawImage(Assets.glows[p.colorName] || Assets.glows.white, p.x - 15, p.y - 15, 30, 30); ctx.globalAlpha = 1; }
                }

                Game.lasers.forEach((l, i) => { l.update(); l.draw(); if(l.dead) Game.lasers.splice(i,1); });
                Game.novas.forEach((n, i) => { n.update(); n.draw(); if(n.dead) Game.novas.splice(i,1); });

                ctx.globalCompositeOperation = 'source-over';
                Game.player.draw();

                for (let i = Game.enemies.length - 1; i >= 0; i--) {
                    let e = Game.enemies[i]; e.update();
                    if (e.dead) { enemyPool.release(e); Game.enemies.splice(i, 1); } else e.draw();
                }

                [Game.eBullets, Game.pickups, Game.texts].forEach(arr => {
                    for(let i = arr.length-1; i>=0; i--) { arr[i].update(); arr[i].draw(); if(arr[i].dead) arr.splice(i, 1); }
                });

                const cdPct = Game.player.dashCd / Game.player.maxDashCd;
                document.getElementById('dash-cd').style.height = (cdPct * 100) + '%';
                
                const ultPct = Math.min(100, Game.player.ultCharge);
                document.getElementById('ult-bar').style.width = ultPct + '%';
                if(ultPct >= 100) document.getElementById('ult-btn').style.display = 'flex';

                if(Game.bossActive && !Game.bossActive.dead) {
                    document.getElementById('boss-hp-fill').style.width = (Game.bossActive.hp / Game.bossActive.maxHp * 100) + '%';
                }
            }
        };
        window.Game = Game;

        class Player {
            constructor() {
                this.x = cw/2; this.y = ch/2; this.r = 12;
                this.stats = { hp: 100, maxHp: 100, speed: 5, dmg: 15, fireRate: 20, count: 1, pierce: 0, magnet: 150, critRate: 0.05, critDmg: 2.0 };
                this.skills = { homing: 0, explosive: 0, laser: 0, timeStop: 0, multiShot: 0, nova: 0, crit: 0 };
                this.dashCd = 0; this.maxDashCd = 60; this.dashing = false; this.dashTime = 0;
                this.xp = 0; this.lvl = 1; this.nextXp = 30;
                this.shootTimer = 0; this.laserTimer = 0; this.timeStopTimer = 0; this.novaTimer = 0;
                this.ultCharge = 0; this.ultActive = false; this.ultTimer = 0;
                this.joystickId = null; this.joySX = 0; this.joySY = 0; // Floating joystick
            }

            update() {
                let dx = 0, dy = 0;
                if(Input.keys['w']) dy = -1; if(Input.keys['s']) dy = 1;
                if(Input.keys['a']) dx = -1; if(Input.keys['d']) dx = 1;
                
                // Floating Joystick Logic
                if (Input.touch.active && Input.touch.id !== null) {
                    // Current touch position
                    const touches = Input.touch.touches;
                    // Find the touch that started movement
                    // We assume Input.touch.touches stores current pos by ID if we implement fully, 
                    // but for simplicity in this structure:
                    dx = (Input.touch.currX - Input.touch.startX) / 50;
                    dy = (Input.touch.currY - Input.touch.startY) / 50;
                }
                
                if(this.dashCd > 0) this.dashCd--;
                if((Input.keys[' '] || Input.touch.dash) && this.dashCd <= 0) {
                    this.dashing = true; this.dashTime = 10; this.dashCd = this.maxDashCd;
                    Input.touch.dash = false;
                    Sfx.play('dash');
                    for(let i=0; i<6; i++) Game.particles.push(particlePool.get(this.x, this.y, 'cyan', 3));
                }

                let speed = this.stats.speed;
                if(this.dashing) { speed *= 2.5; this.dashTime--; if(this.dashTime <= 0) this.dashing = false; }
                
                const dist = Math.hypot(dx, dy);
                if(dist > 1) { dx/=dist; dy/=dist; }
                this.x += dx * speed; this.y += dy * speed;
                this.x = Math.max(15, Math.min(cw-15, this.x)); this.y = Math.max(15, Math.min(ch-15, this.y));

                if(Game.starfield) Game.starfield.update(dx*speed, dy*speed);
                if(Game.frame % 5 === 0) this.checkSkills();

                this.shootTimer++;
                const fireRate = this.ultActive ? 4 : Math.max(5, this.stats.fireRate);
                if(this.shootTimer >= fireRate) {
                    const target = this.getClosestEnemy();
                    if(target) { this.shoot(target, this.ultActive); this.shootTimer = 0; }
                }

                for (let i = Game.pickups.length - 1; i >= 0; i--) {
                    let p = Game.pickups[i];
                    const d = Math.hypot(p.x - this.x, p.y - this.y);
                    if(d < this.stats.magnet) { p.x += (this.x-p.x)*0.2; p.y += (this.y-p.y)*0.2; }
                    if(d < this.r + p.r) p.collect();
                }

                if(this.ultActive) {
                    this.ultTimer--;
                    if(this.ultTimer <= 0) {
                        this.ultActive = false;
                        if(!Game.timeStopActive) document.getElementById('fx-layer').className = '';
                    }
                }
            }

            checkSkills() {
                if(this.skills.laser > 0) {
                    const cd = Math.max(40, 180 - (this.skills.laser * 25));
                    if((this.laserTimer+=5) >= cd) {
                        const t = this.getClosestEnemy();
                        if(t) { Game.lasers.push(new Laser(this.x, this.y, t.x, t.y, this.skills.laser)); this.laserTimer = 0; }
                    }
                }
                if(this.skills.timeStop > 0) {
                    const cd = 900; 
                    if((this.timeStopTimer+=5) >= cd) {
                        Game.activateTimeStop(120 + (this.skills.timeStop * 30)); this.timeStopTimer = 0;
                    }
                }
                if(this.skills.nova > 0) {
                    const cd = 120;
                    if((this.novaTimer+=5) >= cd) { Game.novas.push(new Nova(this.x, this.y, this.skills.nova)); this.novaTimer = 0; }
                }
            }

            getClosestEnemy() {
                let close = null; let minD = Infinity;
                const scanLimit = Math.min(Game.enemies.length, 20); 
                for(let i=0; i<scanLimit; i++) {
                    let e = Game.enemies[i];
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if(d < minD) { minD = d; close = e; }
                }
                return close;
            }

            shoot(target, rapid=false) {
                if(!rapid) Sfx.play('shoot');
                const baseAngle = Math.atan2(target.y - this.y, target.x - this.x);
                const cnt = this.stats.count + this.skills.multiShot;
                for(let i=0; i<cnt; i++) {
                    const spread = cnt > 1 ? (i/(cnt-1)-0.5)*0.3 : 0;
                    Game.bullets.push(bulletPool.get(this.x, this.y, baseAngle+spread, this.skills, this.stats));
                }
            }

            hit(dmg) {
                if(this.dashing || this.ultActive) return;
                this.stats.hp -= dmg;
                const pct = Math.max(0, this.stats.hp / this.stats.maxHp * 100);
                document.getElementById('hp-bar').style.width = pct + '%';
                document.getElementById('hp-val').innerText = Math.floor(this.stats.hp);
                if(this.stats.hp <= 0) Game.over();
            }

            gainXp(amt) {
                this.xp += amt;
                this.ultCharge = Math.min(100, this.ultCharge + (amt/4));
                if(this.xp >= this.nextXp) {
                    this.xp -= this.nextXp;
                    this.lvl++;
                    this.nextXp = Math.floor(30 + (this.lvl * 25) * 1.2);
                    document.getElementById('lvl-txt').innerText = this.lvl;
                    Sfx.play('level');
                    Upgrades.show();
                    const heal = this.stats.maxHp * 0.2;
                    this.stats.hp = Math.min(this.stats.maxHp, this.stats.hp + heal);
                    document.getElementById('hp-bar').style.width = (this.stats.hp/this.stats.maxHp*100) + '%';
                    document.getElementById('hp-val').innerText = Math.floor(this.stats.hp);
                }
                document.getElementById('xp-bar').style.width = (this.xp/this.nextXp*100)+'%';
            }

            draw() {
                ctx.fillStyle = '#000';
                ctx.strokeStyle = this.ultActive ? '#f00' : '#00f3ff'; 
                ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.globalCompositeOperation = 'lighter';
                ctx.drawImage(Assets.glows.cyan, this.x - 30, this.y - 30);
                ctx.globalCompositeOperation = 'source-over';
                
                // Draw Joystick if active
                if(Input.touch.active && Input.touch.id !== null) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.beginPath(); ctx.arc(Input.touch.startX, Input.touch.startY, 40, 0, Math.PI*2); 
                    ctx.strokeStyle = '#fff'; ctx.stroke();
                    ctx.beginPath(); ctx.arc(Input.touch.currX, Input.touch.currY, 20, 0, Math.PI*2); 
                    ctx.fillStyle = '#fff'; ctx.fill();
                    ctx.restore();
                }
            }
        }

        class Enemy {
            constructor() { this.init(); }
            init(type, config) {
                if(!type) return; 
                const angle = Math.random() * Math.PI * 2;
                const d = Math.max(cw, ch) * 0.7 + Math.random()*200;
                this.x = Game.player.x + Math.cos(angle) * d;
                this.y = Game.player.y + Math.sin(angle) * d;
                this.type = type;
                this.dead = false;
                
                const timeFactor = 1 + (Game.time / 300);
                this.hp = config.hp * timeFactor;
                this.maxHp = this.hp;
                this.sp = config.sp;
                this.xp = config.xp;
                this.colName = config.colName; 
                this.r = config.r || 15;
                this.dmg = config.dmg || 5;
                this.pushX = 0; this.pushY = 0;
                this.frozen = 0;
                this.hitFlash = 0;
                
                if(type === 'boss') {
                    this.x = Game.player.x; this.y = Game.player.y - 500;
                    this.name = config.name;
                    this.state = 'idle'; this.timer = 0;
                    Game.bossActive = this;
                    const ui = document.getElementById('boss-hp-container');
                    ui.style.display = 'block';
                    document.getElementById('boss-name').innerText = this.name.toUpperCase();
                }
                return this;
            }

            update() {
                if (this.hitFlash > 0) this.hitFlash--;
                if (Game.timeStopActive && this.type !== 'boss') return; 
                if (this.frozen > 0) { this.frozen--; return; }

                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const dist = Math.hypot(dx, dy);
                const angle = Math.atan2(dy, dx);

                if (this.type === 'shooter') {
                    if (dist > 350) { this.x += Math.cos(angle) * this.sp; this.y += Math.sin(angle) * this.sp; }
                    else if (dist < 200) { this.x -= Math.cos(angle) * this.sp; this.y -= Math.sin(angle) * this.sp; }
                    if (Game.frame % 120 === 0 && dist < 700) Game.eBullets.push(new EnemyBullet(this.x, this.y, angle, 6));
                }
                else if (this.type === 'boss') {
                    this.updateBoss(dist, angle);
                }
                else {
                    this.x += Math.cos(angle) * this.sp;
                    this.y += Math.sin(angle) * this.sp;
                }

                this.x += this.pushX; this.y += this.pushY;
                this.pushX *= 0.9; this.pushY *= 0.9;

                if (dist < this.r + Game.player.r) {
                    Game.player.hit(this.dmg);
                    this.pushX = -Math.cos(angle) * 10;
                    this.pushY = -Math.sin(angle) * 10;
                }
            }

            updateBoss(dist, angle) {
                this.timer++;
                if(this.state === 'idle') {
                    this.x += Math.cos(angle) * (this.sp * 0.5); 
                    this.y += Math.sin(angle) * (this.sp * 0.5);
                    if(this.timer > 100) {
                        const rand = Math.random();
                        if(rand < 0.4) this.state = 'charge';
                        else if(rand < 0.7) this.state = 'barrage';
                        else this.state = 'summon';
                        this.timer = 0;
                    }
                }
                else if(this.state === 'charge') {
                    if(this.timer > 40 && this.timer < 70) {
                        this.x += Math.cos(angle) * (this.sp * 4);
                        this.y += Math.sin(angle) * (this.sp * 4);
                    }
                    if(this.timer > 90) { this.state = 'idle'; this.timer = 0; }
                }
                else if(this.state === 'barrage') {
                    if(this.timer % 5 === 0) {
                        const offset = (this.timer/5) * 0.2;
                        for(let i=0; i<5; i++) Game.eBullets.push(new EnemyBullet(this.x, this.y, (Math.PI*2/5)*i + offset, 5));
                    }
                    if(this.timer > 60) { this.state = 'idle'; this.timer = 0; }
                }
                else if(this.state === 'summon') {
                    if(this.timer === 30) for(let i=0; i<3; i++) Game.enemies.push(enemyPool.get('fast', Director.types.fast));
                    if(this.timer > 50) { this.state = 'idle'; this.timer = 0; }
                }
            }

            hit(dmg, kx, ky, isCrit) {
                this.hp -= dmg;
                const resist = (this.type === 'boss' ? 0.1 : (this.type === 'tank' ? 0.3 : 1.0));
                this.pushX = kx * 2 * resist; 
                this.pushY = ky * 2 * resist;
                this.hitFlash = 3; 
                
                if(!Game.player.ultActive) Sfx.play('hit');
                Game.texts.push(new Text(Math.floor(dmg), this.x, this.y - this.r, isCrit ? 24 : 14, isCrit ? '#ff0000' : '#fff'));

                if(this.hp <= 0 && !this.dead) {
                    this.dead = true;
                    if(this.type !== 'boss') {
                        Game.score++;
                        document.getElementById('kill-txt').innerText = Game.score;
                        Game.pickups.push(new Pickup(this.x, this.y, this.xp));
                    }
                    
                    for(let i=0; i<8; i++) Game.particles.push(particlePool.get(this.x, this.y, this.colName, 4));

                    if(this.type === 'boss') {
                        Game.texts.push(new Text("VICTORY!", this.x, this.y, 50, '#ffd700'));
                        Game.bossActive = null;
                        Game.waveConfig.bossSpawned = false;
                        document.getElementById('boss-hp-container').style.display = 'none';
                        Game.player.gainXp(1000);
                        Game.eBullets = [];
                    }
                }
            }

            draw() {
                if(Game.timeStopActive && this.type!=='boss') ctx.globalAlpha = 0.5;
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if(this.hitFlash > 0) {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x - this.r/2, this.y - this.r/2, this.r, this.r);
                    return;
                }

                const sprite = Assets.glows[this.colName] || Assets.glows.red;
                const size = this.r * 2.5; 
                ctx.globalCompositeOperation = 'lighter';
                ctx.drawImage(sprite, this.x - size/2, this.y - size/2, size, size);
                ctx.globalCompositeOperation = 'source-over';
                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        // ... [Bullet, EnemyBullet, Laser, Nova, Particle, Pickup, Text classes remain same] ...
        class Bullet {
            constructor() { this.init(0,0,0,{},{}); }
            init(x, y, a, skills, stats) {
                this.x = x; this.y = y;
                this.vx = Math.cos(a)*12; this.vy = Math.sin(a)*12;
                this.life = 50; this.r = 5;
                this.skills = skills; this.stats = stats;
                this.hitList = []; this.dead = false; this.isExplosive = skills.explosive > 0;
                return this;
            }
            update() {
                if(this.skills.homing > 0) {
                    if(Game.frame % 3 === 0) {
                         const t = Game.player.getClosestEnemy();
                         if(t) {
                             const idealA = Math.atan2(t.y-this.y, t.x-this.x);
                             this.vx += Math.cos(idealA); this.vy += Math.sin(idealA);
                         }
                    }
                }
                this.x += this.vx; this.y += this.vy;
                this.life--; if(this.life<=0) this.dead=true;

                for(let e of Game.enemies) {
                    if(this.hitList.includes(e)) continue;
                    if(Math.abs(e.x - this.x) < e.r+this.r && Math.abs(e.y - this.y) < e.r+this.r) {
                        let dmg = this.stats.dmg;
                        if(this.skills.explosive > 0) {
                            Game.particles.push(particlePool.get(this.x, this.y, 'orange', 2));
                        }
                        e.hit(dmg, this.vx/10, this.vy/10, false);
                        this.hitList.push(e);
                        this.dead = true; 
                        break;
                    }
                }
            }
            draw() {}
        }

        class EnemyBullet {
            constructor(x, y, a, spd) {
                this.x = x; this.y = y; this.vx = Math.cos(a)*spd; this.vy = Math.sin(a)*spd;
                this.r = 6; this.life = 120;
            }
            update() {
                if(Game.timeStopActive) return;
                this.x += this.vx; this.y += this.vy;
                this.life--; if(this.life<=0) this.dead=true;
                if(Math.hypot(Game.player.x-this.x, Game.player.y-this.y) < this.r + Game.player.r) {
                    Game.player.hit(10); this.dead=true;
                }
            }
            draw() { const s = Assets.glows.red; ctx.drawImage(s, this.x - 10, this.y - 10, 20, 20); }
        }

        class Laser {
            constructor(x, y, tx, ty, lvl) {
                this.sx = x; this.sy = y; this.tx = tx; this.ty = ty;
                this.life = 15; this.lvl = lvl;
                Game.enemies.forEach(e => {
                    if(Math.abs(e.x-tx) < 50 && Math.abs(e.y-ty) < 50) e.hit(15*lvl, 0, 0, false);
                });
            }
            update() { this.life--; if(this.life<=0) this.dead=true; }
            draw() {
                ctx.save(); ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = `rgba(0,255,255,${this.life/15})`; ctx.lineWidth = 8;
                ctx.beginPath(); ctx.moveTo(this.sx, this.sy); ctx.lineTo(this.tx, this.ty); ctx.stroke();
                ctx.restore();
            }
        }

        class Nova {
            constructor(x, y, lvl) {
                this.x = x; this.y = y; this.r = 0; this.maxR = 150 + (lvl*50);
                this.life = 30; this.lvl = lvl; this.hit = [];
            }
            update() {
                this.r += this.maxR/30; this.life--; if(this.life<=0) this.dead=true;
                Game.enemies.forEach(e => {
                    if(this.hit.includes(e)) return;
                    if(Math.hypot(e.x-this.x, e.y-this.y) < this.r + e.r) {
                        e.frozen = 60 + (this.lvl*30); e.hit(20*this.lvl, 0, 0, false); this.hit.push(e);
                    }
                });
            }
            draw() {
                ctx.save(); ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = `rgba(100,200,255,${this.life/30})`; ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
                ctx.restore();
            }
        }

        class Particle {
            constructor() { this.init(0,0,'white',1); }
            init(x, y, cName, s) {
                this.x = x; this.y = y; this.colorName = cName;
                const a = Math.random()*Math.PI*2; const sp = Math.random()*3*s;
                this.vx = Math.cos(a)*sp; this.vy = Math.sin(a)*sp;
                this.life = 1; this.dead = false;
                return this;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; if(this.life<=0) this.dead=true; }
            draw() {}
        }

        class Pickup {
            constructor(x, y, v) { this.x=x; this.y=y; this.v=v; this.r=5; }
            update() {}
            collect() { this.dead=true; Game.player.gainXp(this.v); }
            draw() { ctx.drawImage(Assets.glows.green, this.x - 10, this.y - 10, 20, 20); }
        }

        class Text {
            constructor(t, x, y, s=16, c='#fff') { this.t=t; this.x=x; this.y=y; this.s=s; this.c=c; this.life=40; }
            update() { this.y-=0.5; this.life--; if(this.life<=0) this.dead=true; }
            draw() { 
                ctx.save(); ctx.globalAlpha=this.life/40; ctx.fillStyle=this.c; 
                ctx.font=`bold ${this.s}px Arial`; ctx.fillText(this.t, this.x, this.y); 
                ctx.restore();
            }
        }

        const Director = {
            types: {
                basic: { hp:10, sp:1.8, xp:5, colName:'purple', r:12, dmg:5 },
                fast: { hp:5, sp:3.5, xp:8, colName:'orange', r:8, dmg:3 },
                tank: { hp:60, sp:0.8, xp:20, colName:'green', r:20, dmg:10 },
                shooter: { hp:12, sp:1.2, xp:10, colName:'red', r:12, dmg:8 },
                kamikaze: { hp:8, sp:5.0, xp:12, colName:'white', r:10, dmg:25 },
                elite: { hp:300, sp:1.5, xp:300, colName:'white', r:30, dmg:15 }
            },
            bosses: [
                { time: 180, name: "Construct", hp: 5000, sp: 1.5, xp: 5000, colName: 'boss' },
                { time: 360, name: "Devourer", hp: 12000, sp: 2.5, xp: 10000, colName: 'boss' },
                { time: 600, name: "The End", hp: 50000, sp: 1.0, xp: 50000, colName: 'boss' }
            ],
            
            update(time, frame) {
                const density = 1 + Math.floor(time / 60);
                if (frame % Math.max(10, 50 - density*2) === 0 && !Game.waveConfig.bossSpawned) {
                    const r = Math.random();
                    let type = 'basic';
                    if (time > 20 && r < 0.3) type = 'fast';
                    if (time > 45 && r < 0.15) type = 'shooter';
                    if (time > 60 && r < 0.1) type = 'kamikaze';
                    if (time > 90 && r < 0.1) type = 'tank';
                    const count = time > 120 ? Math.ceil(Math.random() * density/2) : 1;
                    for(let i=0; i<count; i++) Game.enemies.push(enemyPool.get(type, this.types[type]));
                }
                if (time > 30 && time % 20 === 0 && frame % 60 === 0) this.swarm(10 + Math.floor(time/10));
                if ((time === 60 || (time > 120 && time % 60 === 0)) && frame % 60 === 0 && !Game.waveConfig.bossSpawned) {
                    Game.enemies.push(enemyPool.get('elite', this.types.elite));
                    Game.texts.push(new Text("⚠ ELITE ⚠", Game.player.x, Game.player.y-100, 30, '#fa0'));
                }
                const bossCfg = this.bosses.find(b => b.time === time);
                if (bossCfg && frame % 60 === 0 && !Game.waveConfig.bossSpawned) {
                    Game.enemies.push(enemyPool.get('boss', bossCfg));
                    Game.waveConfig.bossSpawned = true;
                    document.getElementById('boss-hp-container').style.display = 'block';
                }
            },
            swarm(count) {
                for(let i=0; i<count; i++) {
                    const a = (Math.PI*2/count)*i;
                    const e = enemyPool.get('basic', this.types.basic);
                    e.x = Game.player.x + Math.cos(a)*400; e.y = Game.player.y + Math.sin(a)*400;
                    Game.enemies.push(e);
                }
                Game.texts.push(new Text("⚠ SWARM ⚠", Game.player.x, Game.player.y-100, 40, '#f00'));
            }
        };

        const Upgrades = {
            rerolls: 3,
            poolData: [
                { id:'dmg', name:'动能强化', desc:'伤害 +20%', rarity:'common', max:10, type:'mul', val:1.2 },
                { id:'fireRate', name:'极速射击', desc:'射速 +15%', rarity:'common', max:10, type:'mulInv', val:0.85 },
                { id:'count', name:'多重弹道', desc:'子弹数 +1', rarity:'rare', max:5, type:'add', val:1 },
                { id:'critRate', name:'致命节奏', desc:'暴击率 +10%', rarity:'rare', max:5, type:'add', val:0.1 },
                { id:'critDmg', name:'弱点识破', desc:'暴击伤害 +50%', rarity:'rare', max:5, type:'add', val:0.5 },
                { id:'homing', name:'智能追踪', desc:'子弹自动追踪敌人', rarity:'legendary', max:5, skill:true },
                { id:'explosive', name:'高爆弹头', desc:'子弹产生范围爆炸', rarity:'legendary', max:5, skill:true },
                { id:'laser', name:'轨道激光', desc:'周期性激光打击', rarity:'legendary', max:5, skill:true },
                { id:'timeStop', name:'时空力场', desc:'周期性冻结时间', rarity:'rare', max:5, skill:true },
                { id:'nova', name:'冰霜新星', desc:'周期性冻结周围', rarity:'rare', max:5, skill:true },
                { id:'hp', name:'应急治疗', desc:'恢复30%血量', rarity:'common', max:999, type:'heal' }
            ],
            show() {
                Game.paused = true;
                const menu = document.getElementById('upgrade-menu');
                const grid = document.getElementById('card-grid');
                document.getElementById('reroll-btn').innerText = `重置数据 (${this.rerolls})`;
                grid.innerHTML = '';
                let valid = this.poolData.filter(u => {
                    if(u.skill) return Game.player.skills[u.id] < u.max;
                    if(u.type !== 'heal') return true; 
                    return true;
                });
                const choices = [];
                for(let i=0; i<3; i++) {
                    if(valid.length === 0) break;
                    const idx = Math.floor(Math.random()*valid.length);
                    choices.push(valid[idx]);
                    if(valid[idx].rarity === 'legendary') valid.splice(idx, 1); 
                }
                choices.forEach(u => {
                    const el = document.createElement('div');
                    el.className = `card ${u.rarity}`;
                    let curLvl = u.skill ? Game.player.skills[u.id] : 0;
                    let lvlTxt = u.skill ? `LV ${curLvl} ▶ ${curLvl+1}` : '通用强化';
                    if(u.type==='heal') lvlTxt = '即时生效';
                    el.innerHTML = `<h3>${u.name}</h3><div class="desc">${u.desc}</div><div class="level-tag">${lvlTxt}</div>`;
                    el.onclick = () => { this.apply(u); menu.style.display = 'none'; Game.paused = false; };
                    grid.appendChild(el);
                });
                menu.style.display = 'flex';
            },
            apply(u) {
                const p = Game.player;
                if(u.skill) p.skills[u.id]++;
                else if(u.type === 'add') p.stats[u.id] += u.val;
                else if(u.type === 'mul') p.stats[u.id] *= u.val;
                else if(u.type === 'mulInv') p.stats[u.id] = Math.max(2, Math.floor(p.stats[u.id]*u.val));
                else if(u.type === 'heal') {
                    p.stats.hp = Math.min(p.stats.maxHp, p.stats.hp + (p.stats.maxHp*0.3));
                    document.getElementById('hp-bar').style.width = (p.stats.hp/p.stats.maxHp*100)+'%';
                }
            },
            reroll() {
                if(this.rerolls > 0) { this.rerolls--; this.show(); }
            }
        };

        // --- CONTROLS REWRITE ---
        const Input = { 
            keys: {}, 
            touch: { active: false, id: null, startX: 0, startY: 0, currX: 0, currY: 0, dash: false } 
        };
        window.onkeydown = e => Input.keys[e.key] = true;
        window.onkeyup = e => Input.keys[e.key] = false;
        
        // Multi-touch Joystick Handler
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            // Find a new touch on the left side of the screen if we don't have one
            for(let i=0; i<e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (Input.touch.id === null && t.clientX < cw * 0.6) {
                    Input.touch.active = true;
                    Input.touch.id = t.identifier;
                    Input.touch.startX = Input.touch.currX = t.clientX;
                    Input.touch.startY = Input.touch.currY = t.clientY;
                    break;
                }
            }
        }, {passive: false});

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if(Input.touch.active) {
                for(let i=0; i<e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if(t.identifier === Input.touch.id) {
                        Input.touch.currX = t.clientX;
                        Input.touch.currY = t.clientY;
                        break;
                    }
                }
            }
        }, {passive: false});

        canvas.addEventListener('touchend', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === Input.touch.id) {
                    Input.touch.active = false;
                    Input.touch.id = null;
                    break;
                }
            }
        });

        // Skill Buttons Handlers (Pointer Events handles touch/mouse uniformly)
        const dashBtn = document.getElementById('dash-btn');
        dashBtn.onpointerdown = (e) => { e.preventDefault(); Input.touch.dash = true; };
        
        const ultBtn = document.getElementById('ult-btn');
        ultBtn.onpointerdown = (e) => { e.preventDefault(); Game.triggerUlt(); };

    })();
    </script>
</body>
</html>
