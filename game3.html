<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>霓虹深渊：觉醒 (Ver 5.0 平衡版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --primary: #00f3ff;
            --secondary: #ff00ff;
            --warning: #ffaa00;
            --danger: #ff0055;
            --corrupted: #8a00ff;
            --bg: #050505;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            user-select: none;
            touch-action: none;
            color: white;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
        }

        .top-bar {
            padding: 20px;
            display: flex; justify-content: space-between; align-items: flex-start;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            pointer-events: auto;
        }

        .hp-container {
            position: relative;
            width: 250px; height: 25px;
            background: #222; border: 2px solid #555;
            transform: skewX(-20deg);
            margin-bottom: 5px;
        }
        .hp-fill {
            height: 100%; background: var(--danger); width: 100%;
            transition: width 0.1s;
            box-shadow: 0 0 15px var(--danger);
        }
        .hp-text {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 12px; font-weight: bold; color: white; transform: skewX(20deg);
            text-shadow: 1px 1px 2px black;
        }

        .xp-bar-fixed {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 8px; background: #111; z-index: 50;
        }
        .xp-fill {
            height: 100%; background: linear-gradient(90deg, #00f, #0ff); width: 0%;
            transition: width 0.2s; box-shadow: 0 0 10px #0ff;
        }

        /* Dash Button */
        .skill-btn {
            position: absolute; bottom: 40px; right: 40px;
            width: 80px; height: 80px;
            border-radius: 50%;
            border: 2px solid var(--primary);
            background: rgba(0,0,0,0.6);
            display: flex; align-items: center; justify-content: center;
            font-size: 30px;
            box-shadow: 0 0 20px var(--primary);
            pointer-events: auto;
            overflow: hidden;
            transition: transform 0.1s;
        }
        .skill-btn:active { transform: scale(0.9); }
        .skill-cd-mask {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            clip-path: circle(0% at 50% 50%);
        }

        /* Ult Button */
        .ult-btn {
            position: absolute; bottom: 140px; right: 50px;
            width: 60px; height: 60px;
            border-radius: 50%;
            border: 2px solid var(--warning);
            background: rgba(255, 170, 0, 0.2);
            display: none; /* Shown when charge full */
            align-items: center; justify-content: center;
            font-size: 24px;
            box-shadow: 0 0 30px var(--warning);
            pointer-events: auto;
            animation: pulseUlt 1s infinite;
            z-index: 60;
            cursor: pointer;
        }
        @keyframes pulseUlt { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        
        .ult-bar-container {
            position: absolute; bottom: 130px; right: 40px;
            width: 80px; height: 10px; background: #222; border: 1px solid #444;
            display: flex;
        }
        .ult-bar-fill { height: 100%; background: var(--warning); width: 0%; transition: width 0.2s; }

        /* Menus */
        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.92);
            backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center; flex-direction: column;
            z-index: 100; pointer-events: auto;
        }

        .title-glitch {
            font-size: 3.5rem; font-weight: 900; color: #fff;
            text-shadow: 3px 3px var(--secondary), -3px -3px var(--primary);
            margin-bottom: 20px; text-align: center;
            animation: glitch 2s infinite;
        }
        @keyframes glitch {
            0% { transform: translate(0); } 2% { transform: translate(-2px, 2px); }
            4% { transform: translate(2px, -2px); } 6% { transform: translate(0); } 100% { transform: translate(0); }
        }

        .btn {
            background: white; color: black; border: none;
            padding: 15px 40px; font-size: 1.2rem; font-family: 'Orbitron'; font-weight: bold;
            cursor: pointer; transition: 0.2s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            margin: 10px;
        }
        .btn:hover { background: var(--primary); transform: scale(1.05); box-shadow: 0 0 20px var(--primary); }

        /* Hex Cards */
        .grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;
            padding: 20px; max-width: 1000px; width: 90%;
        }
        @media(max-width: 768px) { .grid { grid-template-columns: 1fr; } }

        .card {
            background: linear-gradient(160deg, #1a1a2e, #16213e);
            border: 1px solid #444; border-radius: 12px; padding: 20px;
            cursor: pointer; position: relative; overflow: hidden;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            transition: 0.2s; min-height: 280px;
        }
        .card:hover { transform: translateY(-5px); border-color: white; }
        .card.rare { border-top: 4px solid var(--primary); box-shadow: 0 0 15px rgba(0,243,255,0.2); }
        .card.legendary { border-top: 4px solid var(--warning); box-shadow: 0 0 25px rgba(255,170,0,0.3); }
        .card.corrupted { border-top: 4px solid var(--corrupted); background: #1a0520; }
        .card h3 { margin: 10px 0; }
        .card .desc { color: #aaa; font-size: 0.9rem; flex-grow: 1; display:flex; align-items:center; }
        .card .level-tag { 
            background: #333; padding: 2px 8px; border-radius: 4px; font-size: 0.8rem; margin-top: 10px; color: #fff;
        }
        .card.maxed { opacity: 0.5; pointer-events: none; filter: grayscale(1); }

        .boss-warning {
            position: absolute; top: 30%; width: 100%; text-align: center;
            color: var(--danger); font-size: 3rem; font-weight: 900;
            text-shadow: 0 0 20px red; display: none;
            animation: pulseWarn 0.5s infinite;
        }
        @keyframes pulseWarn { 50% { opacity: 0.5; transform: scale(1.1); } }

        .ult-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(255, 170, 0, 0.1);
            pointer-events: none; display: none;
            z-index: 40;
            box-shadow: inset 0 0 100px var(--warning);
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="ult-overlay" class="ult-overlay"></div>

    <!-- Boss Warning Overlay -->
    <div id="boss-warning" class="boss-warning">⚠ WARNING: BOSS ⚠</div>

    <div id="ui-layer">
        <div class="top-bar">
            <div>
                <div class="hp-container">
                    <div class="hp-fill" id="hp-bar"></div>
                    <div class="hp-text"><span id="hp-val">100</span> / <span id="hp-max">100</span></div>
                </div>
                <div style="font-size:1.2rem; text-shadow:0 0 5px var(--primary);">
                    LV <span id="lvl-txt" style="color:var(--primary)">1</span> | 
                    KILL <span id="kill-txt">0</span>
                </div>
            </div>
            <div style="text-align:right;">
                <div style="font-size:2rem; font-weight:900;" id="time-txt">00:00</div>
                <button class="btn" style="padding: 5px 15px; font-size:0.8rem;" onclick="Game.togglePause()">PAUSE</button>
            </div>
        </div>
        
        <!-- Ult UI -->
        <div class="ult-bar-container">
            <div class="ult-bar-fill" id="ult-bar"></div>
        </div>
        <div class="ult-btn" id="ult-btn">☢</div>

        <!-- Dash UI -->
        <div class="skill-btn" id="dash-btn">
            ⏩
            <div class="skill-cd-mask" id="dash-cd"></div>
        </div>
    </div>

    <div class="xp-bar-fixed"><div class="xp-fill" id="xp-bar"></div></div>

    <!-- Menus -->
    <div id="start-menu" class="modal" style="display:flex;">
        <div class="title-glitch">NEON<br>ABYSS: 5.0</div>
        <div style="color:#aaa; margin-bottom:20px;">数值平衡 • 暴击体系 • 冰霜新星</div>
        <button class="btn" onclick="Game.start()">启动系统</button>
    </div>

    <div id="upgrade-menu" class="modal">
        <h2 style="color:white; margin-bottom:20px;">系统升级 (选择一项)</h2>
        <div class="grid" id="card-grid"></div>
    </div>

    <div id="game-over" class="modal">
        <h1 style="color:var(--danger); font-size:3rem;">SYSTEM CRITICAL</h1>
        <p>生存时间: <span id="final-time"></span></p>
        <p>击杀数: <span id="final-kills"></span></p>
        <button class="btn" onclick="location.reload()">重启系统</button>
    </div>

    <script>
    (function() {
        // --- AUDIO ENGINE ---
        const Sfx = {
            ctx: null,
            init() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            play(type) {
                if(!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const t = this.ctx.currentTime;
                
                if (type === 'shoot') {
                    osc.type = 'square'; osc.frequency.setValueAtTime(800, t); osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                    gain.gain.setValueAtTime(0.05, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                } else if (type === 'hit') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.1);
                } else if (type === 'crit') { // New Crit Sound
                    osc.type = 'square'; osc.frequency.setValueAtTime(1200, t); osc.frequency.linearRampToValueAtTime(800, t + 0.2);
                    gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.2);
                } else if (type === 'level') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(440, t); osc.frequency.setValueAtTime(880, t+0.1);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.5);
                } else if (type === 'ult') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(50, t); osc.frequency.linearRampToValueAtTime(500, t + 2);
                    gain.gain.setValueAtTime(0.5, t); gain.gain.linearRampToValueAtTime(0, t + 2);
                } else if (type === 'explode') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(10, t + 0.4);
                    gain.gain.setValueAtTime(0.3, t); gain.gain.linearRampToValueAtTime(0, t + 0.4);
                }

                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(t + (type==='ult'?2.0:0.5));
            }
        };

        // --- GAME ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let cw, ch;
        function resize() { cw = canvas.width = window.innerWidth; ch = canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();

        const Game = {
            active: false, paused: false,
            time: 0, frame: 0, score: 0,
            
            player: null,
            enemies: [], eBullets: [], bullets: [], particles: [], pickups: [], texts: [],
            lasers: [], novas: [],
            
            waveConfig: { nextSwarm: 15, bossSpawned: false },
            timeStopActive: false, 
            timeStopDuration: 0,

            start() {
                Sfx.init();
                document.getElementById('start-menu').style.display = 'none';
                this.active = true;
                this.player = new Player();
                this.reset();
                this.loop();
                if(this.timer) clearInterval(this.timer);
                this.timer = setInterval(() => {
                    if(!this.paused && this.active) {
                        this.time++;
                        this.updateTimeDisplay();
                    }
                }, 1000);
            },

            reset() {
                this.enemies = []; this.eBullets = []; this.bullets = [];
                this.particles = []; this.pickups = []; this.texts = []; this.lasers = []; this.novas = [];
                this.time = 0; this.score = 0; this.frame = 0;
                this.timeStopActive = false;
            },

            togglePause() {
                if(!this.active) return;
                this.paused = !this.paused;
                document.getElementById('pause-menu').style.display = this.paused ? 'flex' : 'none';
            },

            over() {
                this.active = false;
                document.getElementById('game-over').style.display = 'flex';
                document.getElementById('final-time').innerText = document.getElementById('time-txt').innerText;
                document.getElementById('final-kills').innerText = this.score;
            },

            updateTimeDisplay() {
                const m = Math.floor(this.time/60).toString().padStart(2,'0');
                const s = (this.time%60).toString().padStart(2,'0');
                document.getElementById('time-txt').innerText = `${m}:${s}`;
            },

            triggerUlt() {
                if(this.player.ultCharge < 100) return;
                this.player.ultCharge = 0;
                this.player.ultActive = true;
                this.player.ultTimer = 300; 
                document.getElementById('ult-btn').style.display = 'none';
                document.getElementById('ult-overlay').style.display = 'block';
                Sfx.play('ult');
                
                // Clear screen effect
                this.enemies.forEach(e => {
                    if(e.type !== 'boss') e.hit(200, (e.x-this.player.x), (e.y-this.player.y), true);
                });
                Game.texts.push(new Text("PURGATORY MODE", this.player.x, this.player.y - 50, 40, '#ffaa00'));
            },

            loop() {
                if(!Game.active) return;
                requestAnimationFrame(Game.loop);
                if(Game.paused) return;
                Game.frame++;

                ctx.fillStyle = this.player?.ultActive ? 'rgba(50, 10, 0, 0.4)' : 'rgba(5, 5, 5, 0.4)';
                ctx.fillRect(0, 0, cw, ch);

                Director.update(Game.time, Game.frame);

                if (this.timeStopActive) {
                    this.timeStopDuration--;
                    if(this.timeStopDuration <= 0) this.timeStopActive = false;
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
                    ctx.fillRect(0,0,cw,ch);
                }

                Game.player.update();
                Game.player.draw();

                [Game.bullets, Game.eBullets, Game.enemies, Game.pickups, Game.particles, Game.texts, Game.lasers, Game.novas].forEach(arr => {
                    for(let i = arr.length-1; i>=0; i--) {
                        arr[i].update();
                        arr[i].draw();
                        if(arr[i].dead) arr.splice(i, 1);
                    }
                });

                // UI Updates
                const cdPct = Game.player.dashCd / Game.player.maxDashCd;
                document.getElementById('dash-cd').style.clipPath = `circle(${cdPct * 100}% at 50% 50%)`;
                
                const ultPct = Math.min(100, Game.player.ultCharge);
                document.getElementById('ult-bar').style.width = ultPct + '%';
                if(ultPct >= 100) document.getElementById('ult-btn').style.display = 'flex';
            }
        };
        window.Game = Game;

        // --- CLASSES ---

        class Player {
            constructor() {
                this.x = cw/2; this.y = ch/2;
                this.r = 10;
                // Base stats
                this.stats = {
                    hp: 100, maxHp: 100, speed: 4, dmg: 10, fireRate: 20, count: 1, 
                    pierce: 0, magnet: 150,
                    critRate: 0.05, critDmg: 2.0 // NEW: Crit stats
                };
                // Skill Levels
                this.skills = {
                    homing: 0, 
                    explosive: 0,
                    laser: 0,
                    timeStop: 0,
                    multiShot: 0,
                    nova: 0, // NEW: Frost Nova
                    crit: 0  // NEW: Crit Boost
                };
                
                this.dashCd = 0; this.maxDashCd = 90;
                this.dashing = false; this.dashTime = 0;
                
                // BALANCE: Increase base XP requirement to slow down leveling
                this.xp = 0; this.lvl = 1; this.nextXp = 60; // Was 10
                this.shootTimer = 0;
                
                this.laserTimer = 0;
                this.timeStopTimer = 0;
                this.novaTimer = 0;

                this.ultCharge = 0; this.ultActive = false; this.ultTimer = 0;
            }

            update() {
                // Input
                let dx = 0, dy = 0;
                if(Input.keys['w']) dy = -1; if(Input.keys['s']) dy = 1;
                if(Input.keys['a']) dx = -1; if(Input.keys['d']) dx = 1;
                if(Input.touch.active) {
                    dx = (Input.touch.currX - Input.touch.startX)/50;
                    dy = (Input.touch.currY - Input.touch.startY)/50;
                }
                
                if(this.dashCd > 0) this.dashCd--;
                if((Input.keys[' '] || Input.touch.dash) && this.dashCd <= 0) {
                    this.dashing = true; this.dashTime = 10; this.dashCd = this.maxDashCd;
                    Input.touch.dash = false;
                    Sfx.play('dash');
                    for(let i=0; i<8; i++) Game.particles.push(new Particle(this.x, this.y, '#0ff', 2));
                }

                let speed = this.stats.speed;
                if(this.dashing) { speed *= 3; this.dashTime--; if(this.dashTime <= 0) this.dashing = false; }
                if(this.ultActive) speed *= 1.5;

                const dist = Math.hypot(dx, dy);
                if(dist > 1) { dx/=dist; dy/=dist; }
                this.x += dx * speed; this.y += dy * speed;
                this.x = Math.max(10, Math.min(cw-10, this.x)); this.y = Math.max(10, Math.min(ch-10, this.y));

                // --- Ult Logic ---
                if(this.ultActive) {
                    this.ultTimer--;
                    if(this.ultTimer <= 0) {
                        this.ultActive = false;
                        document.getElementById('ult-overlay').style.display = 'none';
                    }
                    if(Game.frame % 5 === 0) {
                        const target = this.getClosestEnemy();
                        if(target) this.shoot(target, true); 
                    }
                }

                // --- Passive Skills ---
                
                // Laser
                if(this.skills.laser > 0) {
                    const cd = Math.max(30, 180 - (this.skills.laser * 30)); 
                    this.laserTimer++;
                    if(this.laserTimer >= cd) {
                        const t = this.getClosestEnemy();
                        if(t) {
                            Game.lasers.push(new Laser(this.x, this.y, t.x, t.y, this.skills.laser));
                            this.laserTimer = 0;
                            Sfx.play('laser');
                        }
                    }
                }

                // Time Stop
                if(this.skills.timeStop > 0) {
                    const cd = 600; 
                    this.timeStopTimer++;
                    if(this.timeStopTimer >= cd) {
                        Game.timeStopActive = true;
                        Game.timeStopDuration = 60 + (this.skills.timeStop * 30); 
                        this.timeStopTimer = 0;
                        Game.texts.push(new Text("TIME STOP", this.x, this.y - 50, 30, '#00ffff'));
                    }
                }

                // Frost Nova
                if(this.skills.nova > 0) {
                    const cd = 120; // 2 seconds
                    this.novaTimer++;
                    if(this.novaTimer >= cd) {
                        Game.novas.push(new Nova(this.x, this.y, this.skills.nova));
                        this.novaTimer = 0;
                    }
                }

                // Shoot
                this.shootTimer++;
                const fireRate = this.ultActive ? 5 : this.stats.fireRate;
                if(this.shootTimer >= fireRate) {
                    const target = this.getClosestEnemy();
                    if(target) {
                        this.shoot(target);
                        this.shootTimer = 0;
                    }
                }

                // Magnet
                Game.pickups.forEach(p => {
                    const d = Math.hypot(p.x - this.x, p.y - this.y);
                    if(d < this.stats.magnet) {
                        p.x += (this.x - p.x) * 0.15;
                        p.y += (this.y - p.y) * 0.15;
                    }
                    if(d < this.r + p.r) p.collect();
                });
            }

            getClosestEnemy() {
                let close = null; let minD = Infinity;
                Game.enemies.forEach(e => {
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if(d < minD) { minD = d; close = e; }
                });
                return close;
            }

            shoot(target, isUlt=false) {
                if(!isUlt) Sfx.play('shoot');
                const baseAngle = Math.atan2(target.y - this.y, target.x - this.x);
                const cnt = this.stats.count + this.skills.multiShot;
                
                for(let i=0; i<cnt; i++) {
                    const offset = cnt > 1 ? (i/(cnt-1) - 0.5) * 0.3 : 0;
                    Game.bullets.push(new Bullet(this.x, this.y, baseAngle + offset, this.skills, this.stats));
                }
            }

            hit(dmg) {
                if(this.dashing || this.ultActive) return; 
                this.stats.hp -= dmg;
                const pct = Math.max(0, this.stats.hp / this.stats.maxHp * 100);
                document.getElementById('hp-bar').style.width = pct + '%';
                document.getElementById('hp-val').innerText = Math.floor(this.stats.hp);
                
                ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);
                setTimeout(()=>ctx.setTransform(1,0,0,1,0,0), 50);

                if(this.stats.hp <= 0) Game.over();
            }

            gainXp(amt) {
                this.xp += amt;
                this.ultCharge = Math.min(100, this.ultCharge + (amt/5));

                if(this.xp >= this.nextXp) {
                    this.xp -= this.nextXp;
                    this.lvl++;
                    // BALANCE: Increased scaling from 1.3 to 1.5 to slow down late game leveling
                    this.nextXp = Math.floor(this.nextXp * 1.5);
                    document.getElementById('lvl-txt').innerText = this.lvl;
                    Sfx.play('level');
                    Upgrades.show();
                    // Heal less
                    this.stats.hp = Math.min(this.stats.maxHp, this.stats.hp + 10);
                }
                document.getElementById('xp-bar').style.width = (this.xp/this.nextXp*100)+'%';
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 15; ctx.shadowColor = this.dashing ? '#fff' : (this.ultActive ? '#ffaa00' : '#0ff');
                ctx.fillStyle = this.dashing ? '#fff' : (this.ultActive ? '#ff5500' : '#000');
                ctx.strokeStyle = this.ultActive ? '#ffaa00' : '#0ff'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2); ctx.fill(); ctx.stroke();
                ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }

        class Enemy {
            constructor(type) {
                const angle = Math.random() * Math.PI * 2;
                const d = Math.max(cw, ch) * 0.8;
                this.x = Game.player.x + Math.cos(angle) * d;
                this.y = Game.player.y + Math.sin(angle) * d;
                this.type = type; 
                
                let hpMul = 1 + (Game.time/60); // Faster HP scaling
                if(type === 'basic') { this.hp=15*hpMul; this.sp=2.5; this.col='#f0f'; this.xp=5; this.r=12; }
                if(type === 'fast') { this.hp=8*hpMul; this.sp=4.5; this.col='#fa0'; this.xp=8; this.r=8; }
                if(type === 'shooter') { this.hp=15*hpMul; this.sp=1.2; this.col='#f00'; this.xp=10; this.r=12; }
                if(type === 'tank') { this.hp=80*hpMul; this.sp=1.0; this.col='#0f0'; this.xp=20; this.r=20; }
                if(type === 'elite') { this.hp=300*hpMul; this.maxHp=this.hp; this.sp=1.8; this.col='#fff'; this.xp=100; this.r=30; }
                if(type === 'kamikaze') { this.hp=10*hpMul; this.sp=5.5; this.col='#ff5500'; this.xp=10; this.r=10; } // NEW
                if(type === 'boss') { 
                    this.hp=15000*hpMul; this.maxHp=this.hp; this.sp=2; this.col='#f00'; this.xp=2000; this.r=60; 
                    this.x = Game.player.x; this.y = Game.player.y - 400; 
                    this.state = 'idle'; this.timer = 0;
                }
                this.pushX = 0; this.pushY = 0;
                this.frozen = 0;
            }

            update() {
                if (Game.timeStopActive && this.type !== 'boss') return; 
                if (this.frozen > 0) { this.frozen--; return; }

                const dx = Game.player.x - this.x;
                const dy = Game.player.y - this.y;
                const dist = Math.hypot(dx, dy);
                const angle = Math.atan2(dy, dx);

                if (this.type === 'shooter') {
                    if (dist > 300) { this.x += Math.cos(angle) * this.sp; this.y += Math.sin(angle) * this.sp; }
                    else if (dist < 200) { this.x -= Math.cos(angle) * this.sp * 0.5; this.y -= Math.sin(angle) * this.sp * 0.5; }
                    if (Game.frame % 100 === 0 && dist < 600) Game.eBullets.push(new EnemyBullet(this.x, this.y, angle));
                } 
                else if (this.type === 'kamikaze') {
                     this.x += Math.cos(angle) * this.sp; this.y += Math.sin(angle) * this.sp;
                     if(dist < 50) { // Explode
                         this.hit(this.hp + 10, 0, 0); // Self destruct
                         Game.particles.push(new Particle(this.x, this.y, '#ff5500', 5));
                         if(dist < 40) Game.player.hit(20);
                         Sfx.play('explode');
                     }
                }
                else if (this.type === 'boss') { this.updateBoss(dist, angle); }
                else { this.x += Math.cos(angle) * this.sp; this.y += Math.sin(angle) * this.sp; }

                this.x += this.pushX; this.y += this.pushY;
                this.pushX *= 0.9; this.pushY *= 0.9;

                if (dist < this.r + Game.player.r) {
                    Game.player.hit(this.type==='boss'?20:5);
                    this.pushX = -Math.cos(angle)*10; this.pushY = -Math.sin(angle)*10;
                }
            }

            updateBoss(dist, angle) {
                this.timer++;
                if (this.state === 'idle') {
                    this.x += Math.cos(angle) * 1; this.y += Math.sin(angle) * 1;
                    if (this.timer > 120) { this.state = Math.random() > 0.5 ? 'charge' : 'nova'; this.timer = 0; }
                }
                else if (this.state === 'charge') {
                    if (this.timer < 60) {
                        ctx.strokeStyle = 'rgba(255,0,0,0.5)'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(Game.player.x, Game.player.y); ctx.stroke();
                    } 
                    else if (this.timer === 60) { this.vx = Math.cos(angle) * 15; this.vy = Math.sin(angle) * 15; }
                    else if (this.timer < 90) { this.x += this.vx; this.y += this.vy; }
                    else { this.state = 'idle'; this.timer = 0; }
                }
                else if (this.state === 'nova') {
                    if (this.timer % 10 === 0 && this.timer < 60) {
                        for(let i=0; i<8; i++) Game.eBullets.push(new EnemyBullet(this.x, this.y, (Math.PI*2/8)*i + this.timer));
                    }
                    if (this.timer > 100) { this.state = 'idle'; this.timer = 0; }
                }
            }

            hit(dmg, kx, ky, isCrit=false) {
                this.hp -= dmg;
                this.pushX = kx * 2; this.pushY = ky * 2;
                if(!Game.player.ultActive) Sfx.play('hit');
                
                // Critical visual
                if (isCrit) {
                    Game.texts.push(new Text(Math.floor(dmg) + "!", this.x, this.y, 24, '#ff0000'));
                    Sfx.play('crit');
                } else {
                    Game.texts.push(new Text(Math.floor(dmg), this.x, this.y));
                }

                if (this.hp <= 0 && !this.dead) {
                    this.dead = true;
                    Game.score++;
                    document.getElementById('kill-txt').innerText = Game.score;
                    Game.pickups.push(new Pickup(this.x, this.y, this.xp));
                    for(let i=0; i<5; i++) Game.particles.push(new Particle(this.x, this.y, this.col));

                    if(this.type === 'boss' || this.type === 'elite') {
                        Game.texts.push(new Text(this.type === 'boss' ? "BOSS SLAIN" : "ELITE SLAIN", this.x, this.y, 30, '#ffd700'));
                        if(this.type === 'boss') {
                            Game.enemies = Game.enemies.filter(e=>e.type!=='boss'); 
                            Game.player.stats.hp = Game.player.stats.maxHp;
                            Game.player.gainXp(5000);
                            Game.waveConfig.bossSpawned = false;
                        }
                    }
                }
            }

            draw() {
                if (Game.timeStopActive && this.type!=='boss') ctx.globalAlpha = 0.5;
                if (this.frozen > 0) ctx.fillStyle = '#00ffff'; // Frozen visual
                
                ctx.save();
                ctx.translate(this.x, this.y);
                if (this.frozen <= 0) ctx.fillStyle = this.col;

                if (this.type === 'elite') {
                    ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
                    ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
                    ctx.strokeStyle='#000'; ctx.lineWidth=2; ctx.stroke();
                } else if (this.type === 'boss') {
                    ctx.shadowBlur = 20; ctx.shadowColor = 'red';
                    ctx.rotate(Game.frame * 0.05); ctx.fillRect(-this.r, -this.r, this.r*2, this.r*2);
                    ctx.rotate(-Game.frame * 0.05);
                    ctx.fillStyle = 'red'; ctx.fillRect(-40, -80, 80, 8);
                    ctx.fillStyle = '#0f0'; ctx.fillRect(-40, -80, 80*(this.hp/this.maxHp), 8);
                } else {
                    ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
                }
                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }

        class Bullet {
            constructor(x, y, a, skills, stats) {
                this.x = x; this.y = y;
                this.vx = Math.cos(a) * 10; this.vy = Math.sin(a) * 10;
                this.life = 60; this.r = 4;
                this.pierce = stats.pierce;
                this.hitList = [];
                this.homingLvl = skills.homing;
                this.explosiveLvl = skills.explosive;
                this.critRate = stats.critRate;
                this.critDmg = stats.critDmg;
            }
            update() {
                if (this.homingLvl > 0) {
                    const target = Game.player.getClosestEnemy();
                    if (target) {
                        const angle = Math.atan2(target.y - this.y, target.x - this.x);
                        const strength = 0.1 + (this.homingLvl * 0.1); 
                        this.vx = this.vx * (1-strength) + Math.cos(angle) * 10 * strength;
                        this.vy = this.vy * (1-strength) + Math.sin(angle) * 10 * strength;
                    }
                }
                this.x += this.vx; this.y += this.vy;
                this.life--;
                if(this.life<=0) this.dead=true;

                for(let e of Game.enemies) {
                    if(this.hitList.includes(e)) continue;
                    if(Math.hypot(e.x-this.x, e.y-this.y) < e.r + this.r + 5) { 
                        let dmg = Game.player.stats.dmg;
                        if(this.explosiveLvl > 0) dmg *= (1 + this.explosiveLvl * 0.2); 
                        
                        // Critical Hit Logic
                        const isCrit = Math.random() < this.critRate;
                        if (isCrit) dmg *= this.critDmg;

                        e.hit(dmg, this.vx/10, this.vy/10, isCrit);
                        this.hitList.push(e);

                        if (this.explosiveLvl > 0) {
                            const range = 50 + (this.explosiveLvl * 20);
                            Game.particles.push(new Particle(this.x, this.y, '#fa0', range/20));
                            Game.enemies.forEach(subE => {
                                if (subE !== e && Math.hypot(subE.x-this.x, subE.y-this.y) < range) {
                                    subE.hit(dmg * 0.5, 0, 0);
                                }
                            });
                        }
                        if(this.pierce > 0) this.pierce--;
                        else {
                            this.dead = true;
                            Game.particles.push(new Particle(this.x, this.y, '#0ff'));
                            break;
                        }
                    }
                }
            }
            draw() {
                ctx.fillStyle = this.explosiveLvl > 0 ? '#fa0' : '#fff';
                ctx.shadowBlur = 5; ctx.shadowColor = this.explosiveLvl > 0 ? '#f00' : '#0ff';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Laser {
            constructor(x, y, tx, ty, level) {
                this.x = x; this.y = y; this.tx = tx; this.ty = ty;
                this.level = level;
                this.life = 15;
                const angle = Math.atan2(ty-y, tx-x);
                Game.enemies.forEach(e => {
                   if (Math.hypot(e.x-tx, e.y-ty) < 50 + (level*20)) {
                       e.hit(20 * level, 0, 0);
                   }
                });
            }
            update() { this.life--; if(this.life<=0) this.dead=true; }
            draw() {
                ctx.strokeStyle = `rgba(0, 255, 255, ${this.life/15})`;
                ctx.lineWidth = 5 + this.level * 2;
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.tx, this.ty); ctx.stroke();
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.life/15})`;
                ctx.lineWidth = 2; ctx.stroke();
            }
        }

        class Nova {
            constructor(x, y, level) {
                this.x = x; this.y = y; this.level = level;
                this.r = 0; this.maxR = 100 + (level*30);
                this.life = 30;
                this.hitList = [];
            }
            update() {
                this.r += this.maxR / 30;
                this.life--;
                if(this.life<=0) this.dead = true;
                
                Game.enemies.forEach(e => {
                    if (this.hitList.includes(e)) return;
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < this.r + e.r && d > this.r - 20) {
                        e.frozen = 60 + (this.level * 30); // Freeze enemy
                        e.hit(10 * this.level, (e.x-this.x)/d*5, (e.y-this.y)/d*5);
                        this.hitList.push(e);
                    }
                });
            }
            draw() {
                ctx.strokeStyle = `rgba(100, 200, 255, ${this.life/30})`;
                ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
            }
        }

        class EnemyBullet {
            constructor(x, y, a) {
                this.x = x; this.y = y;
                this.vx = Math.cos(a) * 4; this.vy = Math.sin(a) * 4;
                this.r = 6; this.life = 100;
            }
            update() {
                if (Game.timeStopActive) return;
                this.x += this.vx; this.y += this.vy;
                this.life--; if(this.life<=0) this.dead=true;
                if (Math.hypot(Game.player.x - this.x, Game.player.y - this.y) < this.r + Game.player.r) {
                    Game.player.hit(8); this.dead = true;
                }
            }
            draw() {
                ctx.fillStyle = '#f00'; ctx.shadowBlur = 5; ctx.shadowColor = '#f00';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, col, speed=1) {
                this.x = x; this.y = y; this.col = col;
                const a = Math.random()*Math.PI*2;
                const s = Math.random()*3*speed;
                this.vx = Math.cos(a)*s; this.vy = Math.sin(a)*s;
                this.life = 1.0;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; if(this.life<=0) this.dead=true; }
            draw() { ctx.globalAlpha=this.life; ctx.fillStyle=this.col; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha=1; }
        }

        class Pickup {
            constructor(x, y, xp) { this.x = x; this.y = y; this.xp = xp; this.r=5; }
            update() {} 
            collect() { this.dead=true; Game.player.gainXp(this.xp); }
            draw() { ctx.fillStyle = '#0f0'; ctx.beginPath(); ctx.rect(this.x-3, this.y-3, 6, 6); ctx.fill(); }
        }

        class Text {
            constructor(txt, x, y, size=16, col='#fff') { this.txt=txt; this.x=x; this.y=y; this.size=size; this.col=col; this.life=40; }
            update() { this.y-=1; this.life--; if(this.life<=0) this.dead=true; }
            draw() { 
                ctx.fillStyle=this.col; 
                ctx.font=`bold ${this.size}px 'Orbitron'`; 
                ctx.globalAlpha = this.life/40;
                ctx.fillText(this.txt, this.x, this.y); 
                ctx.globalAlpha = 1;
            }
        }

        // --- DIRECTOR ---
        const Director = {
            update(time, frame) {
                let spawnInterval = Math.max(10, 60 - time);
                if (frame % spawnInterval === 0 && !Game.waveConfig.bossSpawned) {
                    let type = 'basic'; const r = Math.random();
                    if (time > 15 && r < 0.3) type = 'fast';
                    if (time > 30 && r < 0.2) type = 'shooter';
                    if (time > 45 && r < 0.1) type = 'kamikaze'; // New: Exploding enemy
                    if (time > 60 && r < 0.1) type = 'tank';
                    Game.enemies.push(new Enemy(type));
                }
                if (time > 0 && time % 15 === 0 && frame % 60 === 0) this.spawnSwarm(8 + Math.floor(time/5));
                if ((time === 45 || time === 120) && frame % 60 === 0) {
                    Game.enemies.push(new Enemy('elite'));
                    Game.texts.push(new Text("⚠ ELITE ENEMY ⚠", Game.player.x, Game.player.y-100, 30, '#fa0'));
                }
                if (time === 180 && frame % 60 === 0 && !Game.waveConfig.bossSpawned) this.spawnBoss();
            },
            spawnSwarm(count) {
                for(let i=0; i<count; i++) {
                    const a = (Math.PI*2/count)*i;
                    const e = new Enemy('basic'); const dist = 300;
                    e.x = Game.player.x + Math.cos(a)*dist; e.y = Game.player.y + Math.sin(a)*dist;
                    Game.enemies.push(e);
                }
                Game.texts.push(new Text("⚠ SWARM ⚠", Game.player.x, Game.player.y-100, 30, '#fa0'));
            },
            spawnBoss() {
                Game.enemies.push(new Enemy('boss'));
                Game.waveConfig.bossSpawned = true;
                const warn = document.getElementById('boss-warning');
                warn.style.display = 'block';
                setTimeout(() => warn.style.display = 'none', 3000);
            }
        };

        // --- UPGRADES ---
        const Upgrades = {
            getPool() {
                const p = Game.player;
                const s = p.skills;
                const options = [
                    { id: 'dmg', name: '动能强化', desc: '伤害 +25%', rarity: 'common', type:'mul', val: 1.25 },
                    { id: 'fireRate', name: '极速射击', desc: '射速 +15%', rarity: 'common', type:'mulInv', val: 0.85 },
                    { id: 'hp', name: '应急治疗', desc: '恢复血量 & 上限+20', rarity: 'common', special: (p)=>{ p.stats.maxHp+=20; p.stats.hp=Math.min(p.stats.maxHp, p.stats.hp+30); } },
                    
                    { 
                        id: 'crit', name: '致命节奏', rarity: 'rare', max: 5, current: s.crit,
                        desc: s.crit===0 ? '解锁暴击: 10%几率双倍伤害' : `等级 ${s.crit+1}: 暴击率+10%, 爆伤+50%`,
                        apply: (p)=> { p.skills.crit++; p.stats.critRate += 0.1; p.stats.critDmg += 0.5; } 
                    },

                    { 
                        id: 'multiShot', name: '多重弹道', rarity: 'rare', max: 5, current: s.multiShot,
                        desc: s.multiShot===0 ? '解锁多重射击' : `等级 ${s.multiShot+1}: 弹道数量 +1`,
                        apply: (p)=>p.skills.multiShot++ 
                    },
                    
                    { 
                        id: 'homing', name: '智能追踪', rarity: 'legendary', max: 5, current: s.homing,
                        desc: s.homing===0 ? '解锁子弹自动追踪' : `等级 ${s.homing+1}: 追踪灵敏度大幅提升`,
                        apply: (p)=>p.skills.homing++ 
                    },

                    { 
                        id: 'explosive', name: '高爆弹头', rarity: 'rare', max: 5, current: s.explosive,
                        desc: s.explosive===0 ? '解锁爆炸伤害' : `等级 ${s.explosive+1}: 爆炸范围与伤害提升`,
                        apply: (p)=>p.skills.explosive++ 
                    },

                    { 
                        id: 'laser', name: '轨道激光', rarity: 'legendary', max: 5, current: s.laser,
                        desc: s.laser===0 ? '解锁自动激光打击' : `等级 ${s.laser+1}: 冷却时间减少, 伤害增加`,
                        apply: (p)=>p.skills.laser++ 
                    },

                    { 
                        id: 'timeStop', name: '时空力场', rarity: 'rare', max: 5, current: s.timeStop,
                        desc: s.timeStop===0 ? '解锁周期性时停' : `等级 ${s.timeStop+1}: 冻结时间延长`,
                        apply: (p)=>p.skills.timeStop++ 
                    },

                    { 
                        id: 'nova', name: '冰霜新星', rarity: 'rare', max: 5, current: s.nova,
                        desc: s.nova===0 ? '解锁冰环冻结敌人' : `等级 ${s.nova+1}: 范围扩大, 伤害增加`,
                        apply: (p)=>p.skills.nova++ 
                    }
                ];
                return options.filter(u => !u.max || u.current < u.max);
            },

            show() {
                Game.paused = true;
                const menu = document.getElementById('upgrade-menu');
                const grid = document.getElementById('card-grid');
                grid.innerHTML = '';

                let pool = this.getPool();
                const choices = [];
                for(let i=0; i<3; i++) {
                    if(pool.length === 0) break;
                    const idx = Math.floor(Math.random() * pool.length);
                    choices.push(pool[idx]);
                    pool.splice(idx, 1);
                }

                choices.forEach(u => {
                    const el = document.createElement('div');
                    el.className = `card ${u.rarity}`;
                    
                    let levelHTML = '';
                    if(u.max) levelHTML = `<div class="level-tag">当前等级: ${u.current} / ${u.max}</div>`;
                    
                    el.innerHTML = `<h3>${u.name}</h3><div class="desc">${u.desc}</div>${levelHTML}<small style="margin-top:auto; color:#666">[ ${u.rarity.toUpperCase()} ]</small>`;
                    el.onclick = () => {
                        this.apply(u);
                        menu.style.display = 'none';
                        Game.paused = false;
                    };
                    grid.appendChild(el);
                });
                menu.style.display = 'flex';
            },

            apply(u) {
                const p = Game.player;
                if(u.apply) u.apply(p);
                else if(u.special) u.special(p);
                else if(u.type==='mul') p.stats[u.id] *= u.val;
                else if(u.type==='mulInv') p.stats[u.id] = Math.max(2, Math.floor(p.stats[u.id]*u.val));
            }
        };

        // --- CONTROLS ---
        const Input = { keys: {}, touch: { active:false, startX:0, startY:0, currX:0, currY:0, dash:false } };
        window.onkeydown = e => Input.keys[e.key] = true;
        window.onkeyup = e => Input.keys[e.key] = false;
        
        canvas.ontouchstart = e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            if(t.clientX < cw/2) {
                Input.touch.active = true;
                Input.touch.startX = Input.touch.currX = t.clientX;
                Input.touch.startY = Input.touch.currY = t.clientY;
            }
        };
        canvas.ontouchmove = e => {
            if(Input.touch.active) {
                const t = e.changedTouches[0];
                Input.touch.currX = t.clientX; Input.touch.currY = t.clientY;
            }
        };
        canvas.ontouchend = e => Input.touch.active = false;

        const dashBtn = document.getElementById('dash-btn');
        dashBtn.ontouchstart = (e) => { e.preventDefault(); Input.touch.dash = true; };
        dashBtn.onmousedown = (e) => { e.preventDefault(); Input.touch.dash = true; };
        
        const ultBtn = document.getElementById('ult-btn');
        ultBtn.ontouchstart = (e) => { e.preventDefault(); Game.triggerUlt(); };
        ultBtn.onmousedown = (e) => { e.preventDefault(); Game.triggerUlt(); };

    })();
    </script>
</body>
</html>
